/**
 * Generated by Apache Royale Compiler from io/nfg/core/pathfinding/Simple.as
 * io.nfg.core.pathfinding.Simple
 *
 * @fileoverview
 *
 * @suppress {checkTypes|accessControls}
 */

goog.provide('io.nfg.core.pathfinding.Simple');

goog.require('io.nfg.core.Pos');



/**
 * @constructor
 */
io.nfg.core.pathfinding.Simple = function() {
};


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('io.nfg.core.pathfinding.Simple', io.nfg.core.pathfinding.Simple);


/**
 * @export
 * @param {io.nfg.core.Pos} a
 * @param {io.nfg.core.Pos} b
 * @return {number}
 */
io.nfg.core.pathfinding.Simple.euclidean = function(a, b) {
  return (b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y);
};


/**
 * @export
 * @param {io.nfg.core.Pos} from
 * @param {io.nfg.core.Pos} goal
 * @param {Array} grid
 * @param {Array} tilesInRange
 * @param {number} range
 * @return {Array}
 */
io.nfg.core.pathfinding.Simple.reach = function(from, goal, grid, tilesInRange, range) {
  var /** @type {Array} */ result = [];
  var /** @type {io.nfg.core.Pos} */ goal2 = new io.nfg.core.Pos(goal.x, goal.y);
  if (!grid[goal2.y][goal2.x] && Math.sqrt(io.nfg.core.pathfinding.Simple.euclidean(from, goal2)) <= range) {
    result.push(goal2);
  } else {
    var /** @type {io.nfg.core.Pos} */ point = new io.nfg.core.Pos();
    var /** @type {number} */ minDistance = io.nfg.core.pathfinding.Simple.euclidean(from, goal);
    var /** @type {number} */ distance;
    var /** @type {number} */ range2 = range * range;
    var foreachiter0_target = tilesInRange;
    for (var foreachiter0 in foreachiter0_target) 
    {
    point = foreachiter0_target[foreachiter0];
    {
      distance = io.nfg.core.pathfinding.Simple.euclidean(point, goal);
      if (distance < minDistance) {
        minDistance = distance;
        goal2 = point;
      }
    }}
    
    if (goal.equals(goal2) == false) {
      result.push(goal2);
    }
  }
  return result;
};


/**
 * @export
 * @param {io.nfg.core.Pos} start
 * @param {number} range
 * @param {Array} grid
 * @param {boolean=} ignoreBlockedTiles
 * @return {Array}
 */
io.nfg.core.pathfinding.Simple.explore = function(start, range, grid, ignoreBlockedTiles) {
  ignoreBlockedTiles = typeof ignoreBlockedTiles !== 'undefined' ? ignoreBlockedTiles : false;
  var /** @type {Function} */ __localFn0__ = function(row, col) {
    return true;
  }
  var /** @type {Function} */ __localFn1__ = function(row, col) {
    return grid.length > row && grid[row].length > col && !grid[row][col];
  }
  var /** @type {Array} */ result = [], /** @type {number} */ rows = grid.length, /** @type {number} */ cols = Number(grid[0].length), /** @type {number} */ horizontalStart, /** @type {number} */ horizontalEnd, /** @type {number} */ verticalStart, /** @type {number} */ verticalEnd, /** @type {number} */ distance;
  horizontalStart = (start.x - range) > 0 ? start.x - range : 0;
  horizontalEnd = (start.x + range) < cols ? start.x + range : cols;
  verticalStart = (start.y - range) > 0 ? start.y - range : 0;
  verticalEnd = (start.y + range) < rows ? start.y + range : rows;
  var /** @type {number} */ rangeSquare = range * range;
  var /** @type {Function} */ check = ignoreBlockedTiles ? __localFn0__ : __localFn1__;
  for (var /** @type {number} */ col = horizontalStart; col <= horizontalEnd; col++) {
    for (var /** @type {number} */ row = verticalStart; row <= verticalEnd; row++) {
      distance = (col - start.x) * (col - start.x) + (row - start.y) * (row - start.y);
      if (distance <= rangeSquare) {
        if (check(row, col)) {
          result.push(new io.nfg.core.Pos(col, row));
        }
      }
    }
  }
  return result;
};


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
io.nfg.core.pathfinding.Simple.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'Simple', qName: 'io.nfg.core.pathfinding.Simple', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
io.nfg.core.pathfinding.Simple.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {return {};},
    accessors: function () {return {};},
    methods: function () {
      return {
        '|euclidean': { type: 'Number', declaredBy: 'io.nfg.core.pathfinding.Simple', parameters: function () { return [  { index: 1, type: 'io.nfg.core.Pos', optional: false },{ index: 2, type: 'io.nfg.core.Pos', optional: false } ]; }},
        '|reach': { type: 'Vector.<io.nfg.core.Pos>', declaredBy: 'io.nfg.core.pathfinding.Simple', parameters: function () { return [  { index: 1, type: 'io.nfg.core.Pos', optional: false },{ index: 2, type: 'io.nfg.core.Pos', optional: false },{ index: 3, type: 'Array', optional: false },{ index: 4, type: 'Vector.<io.nfg.core.Pos>', optional: false },{ index: 5, type: 'Number', optional: false } ]; }},
        '|explore': { type: 'Vector.<io.nfg.core.Pos>', declaredBy: 'io.nfg.core.pathfinding.Simple', parameters: function () { return [  { index: 1, type: 'io.nfg.core.Pos', optional: false },{ index: 2, type: 'Number', optional: false },{ index: 3, type: 'Array', optional: false },{ index: 4, type: 'Boolean', optional: true } ]; }}
      };
    }
  };
};