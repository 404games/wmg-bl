/**
 * Generated by Apache Royale Compiler from io/nfg/core/pathfinding/AStar.as
 * io.nfg.core.pathfinding.AStar
 *
 * @fileoverview
 *
 * @suppress {checkTypes|accessControls}
 */

goog.provide('io.nfg.core.pathfinding.AStar');

goog.require('io.nfg.core.Pos');
goog.require('io.nfg.core.pathfinding.AStarNode');
goog.require('io.nfg.core.pathfinding.PriorityQueue');
goog.require('org.apache.royale.utils.Language');



/**
 * @constructor
 */
io.nfg.core.pathfinding.AStar = function() {
};


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('io.nfg.core.pathfinding.AStar', io.nfg.core.pathfinding.AStar);


/**
 * @private
 * @type {number}
 */
io.nfg.core.pathfinding.AStar._buffX;


/**
 * @private
 * @type {number}
 */
io.nfg.core.pathfinding.AStar._buffY;


/**
 * @private
 * @type {number}
 */
io.nfg.core.pathfinding.AStar._maxItereations = 100;


/**
 * Performs an A* Pathfinding between given points on a byteArray
 * @asparam start
 * @asparam goal
 * @asparam grid ByteArray, true for occupied tile, false for free tile
 * @asreturn
 * @export
 * @param {io.nfg.core.Pos} start
 * @param {io.nfg.core.Pos} goal
 * @param {Array} grid
 * @param {number=} range
 * @return {Array}
 */
io.nfg.core.pathfinding.AStar.reach = function(start, goal, grid, range) {
  range = typeof range !== 'undefined' ? range : 0;
  var /** @type {number} */ length, /** @type {number} */ i, /** @type {number} */ rows = grid.length, /** @type {number} */ cols = Number(grid[0].length), /** @type {Array} */ closedSet = [], /** @type {Array} */ successors = [], /** @type {io.nfg.core.pathfinding.AStarNode} */ successor, /** @type {Array} */ result = [], /** @type {Function} */ distance = io.nfg.core.pathfinding.AStar.euclidean, /** @type {io.nfg.core.pathfinding.AStarNode} */ current, /** @type {io.nfg.core.pathfinding.PriorityQueue} */ openedSet = new io.nfg.core.pathfinding.PriorityQueue();
  var /** @type {number} */ goalGid = goal.y * cols + goal.x;
  var /** @type {io.nfg.core.pathfinding.AStarNode} */ closestGoal = new io.nfg.core.pathfinding.AStarNode(start.x, start.y);
  closestGoal.g = 0;
  closestGoal.f = Number(distance(closestGoal, goal));
  if (!start.equals(goal)) {
    openedSet.enqueue(closestGoal);
    var /** @type {number} */ iterations = 0;
    do {
      current = org.apache.royale.utils.Language.as(openedSet.dequeue(), io.nfg.core.pathfinding.AStarNode);
      if (current.f < closestGoal.f)
        closestGoal = current;
      if (current.gid != goalGid) {
        successors = (current.p == null) ? io.nfg.core.pathfinding.AStar.getAllSuccessors(current, grid) : io.nfg.core.pathfinding.AStar.getDirSuccessors(current, grid);
        for (i = 0; i < successors.length; i++) {
          successor = successors[i];
          successor.gid = successor.x + successor.y * cols;
          successor.g = current.g + ((current.x == successor.x || current.y == successor.y) ? 1 : 1.41421357);
          if (successor.gid in closedSet) {
            if (successor.g < closedSet[successor.gid].g)
              successor.f = Number(closedSet[successor.gid].f);
            else
              continue;
          }
          else
            successor.f = Number(distance(successor, goal));
          successor.priority = successor.g * successor.g + successor.f;
          successor.p = current;
          openedSet.enqueue(successor);
          closedSet[successor.gid] = successor;
        }
        length = openedSet.size();
      } else {
        length = 0;
      }
    } while (length && iterations++ < io.nfg.core.pathfinding.AStar._maxItereations);
    current = closestGoal;
    do {
      if (range == 0 || current.g <= range) {
        result.unshift(current);
      }
      current = current.p;
    } while (current != null);
    result.shift();
  }
  return result;
};


/**
 * @export
 * @param {io.nfg.core.Pos} start
 * @param {number} range
 * @param {Array} grid
 * @param {number=} dim
 * @return {Array}
 */
io.nfg.core.pathfinding.AStar.explore = function(start, range, grid, dim) {
  dim = typeof dim !== 'undefined' ? dim : 1;
  var /** @type {number} */ i, /** @type {number} */ rows = grid.length, /** @type {number} */ cols = Number(grid[0].length), /** @type {Array} */ closedSet = [], /** @type {Array} */ successors = [], /** @type {io.nfg.core.pathfinding.AStarNode} */ successor, /** @type {Array} */ result = [], /** @type {Function} */ distance = io.nfg.core.pathfinding.AStar.euclidean, /** @type {io.nfg.core.pathfinding.AStarNode} */ current, /** @type {io.nfg.core.pathfinding.PriorityQueue} */ openedSet = new io.nfg.core.pathfinding.PriorityQueue();
  openedSet.enqueue(new io.nfg.core.pathfinding.AStarNode(start.x, start.y));
  closedSet[start.x + start.y * cols] = true;
  do {
    current = org.apache.royale.utils.Language.as(openedSet.dequeue(), io.nfg.core.pathfinding.AStarNode);
    successors = io.nfg.core.pathfinding.AStar.getAllSuccessors(current, grid);
    for (i = 0; i < successors.length; i++) {
      successor = successors[i];
      successor.gid = successor.x + successor.y * cols;
      if (!(successor.gid in closedSet)) {
        successor.priority = current.priority + ((current.x == successor.x || current.y == successor.y) ? 1 : 1.41421357);
        if (successor.priority <= range) {
          closedSet[successor.gid] = true;
          result.push(successor);
          openedSet.enqueue(successor);
        }
      }
    }
  } while (openedSet.size());
  return result;
};


/**
 * @private
 * @param {io.nfg.core.pathfinding.AStarNode} n
 * @param {Array} grid
 * @return {Array}
 */
io.nfg.core.pathfinding.AStar.getAllSuccessors = function(n, grid) {
  var /** @type {Array} */ result = [], /** @type {number} */ W = n.x - 1, /** @type {number} */ N = n.y - 1, /** @type {number} */ S = n.y + 1, /** @type {number} */ E = n.x + 1;
  if (!grid[N][W])
    result.push(new io.nfg.core.pathfinding.AStarNode(W, N));
  if (!grid[N][n.x])
    result.push(new io.nfg.core.pathfinding.AStarNode(n.x, N));
  if (!grid[N][E])
    result.push(new io.nfg.core.pathfinding.AStarNode(E, N));
  if (!grid[n.y][W])
    result.push(new io.nfg.core.pathfinding.AStarNode(W, n.y));
  if (!grid[n.y][E])
    result.push(new io.nfg.core.pathfinding.AStarNode(E, n.y));
  if (!grid[S][W])
    result.push(new io.nfg.core.pathfinding.AStarNode(W, S));
  if (!grid[S][n.x])
    result.push(new io.nfg.core.pathfinding.AStarNode(n.x, S));
  if (!grid[S][E])
    result.push(new io.nfg.core.pathfinding.AStarNode(E, S));
  return result;
};


/**
 * @private
 * @param {io.nfg.core.pathfinding.AStarNode} n
 * @param {Array} grid
 * @return {Array}
 */
io.nfg.core.pathfinding.AStar.getDirSuccessors = function(n, grid) {
  var /** @type {Array} */ result = [], /** @type {number} */ W = n.x - 1, /** @type {number} */ N = n.y - 1, /** @type {number} */ S = n.y + 1, /** @type {number} */ E = n.x + 1;
  var /** @type {io.nfg.core.Pos} */ dir = new io.nfg.core.Pos(n.x - n.p.x, n.y - n.p.y);
  if (dir.y == 0) {
    io.nfg.core.pathfinding.AStar._buffX = n.x + dir.x;
    if (!grid[n.y][io.nfg.core.pathfinding.AStar._buffX])
      result.push(new io.nfg.core.pathfinding.AStarNode(io.nfg.core.pathfinding.AStar._buffX, n.y));
    if (!grid[S][io.nfg.core.pathfinding.AStar._buffX])
      result.push(new io.nfg.core.pathfinding.AStarNode(io.nfg.core.pathfinding.AStar._buffX, S));
    if (!grid[N][io.nfg.core.pathfinding.AStar._buffX])
      result.push(new io.nfg.core.pathfinding.AStarNode(io.nfg.core.pathfinding.AStar._buffX, N));
  } else if (dir.x == 0) {
    io.nfg.core.pathfinding.AStar._buffY = n.y + dir.y;
    if (!grid[io.nfg.core.pathfinding.AStar._buffY][n.x])
      result.push(new io.nfg.core.pathfinding.AStarNode(n.x, io.nfg.core.pathfinding.AStar._buffY));
    if (!grid[io.nfg.core.pathfinding.AStar._buffY][E])
      result.push(new io.nfg.core.pathfinding.AStarNode(E, io.nfg.core.pathfinding.AStar._buffY));
    if (!grid[io.nfg.core.pathfinding.AStar._buffY][W])
      result.push(new io.nfg.core.pathfinding.AStarNode(W, io.nfg.core.pathfinding.AStar._buffY));
  } else {
    io.nfg.core.pathfinding.AStar._buffX = n.x + dir.x;
    io.nfg.core.pathfinding.AStar._buffY = n.y + dir.y;
    if (!grid[n.y][io.nfg.core.pathfinding.AStar._buffX])
      result.push(new io.nfg.core.pathfinding.AStarNode(io.nfg.core.pathfinding.AStar._buffX, n.y));
    if (!grid[io.nfg.core.pathfinding.AStar._buffY][n.x])
      result.push(new io.nfg.core.pathfinding.AStarNode(n.x, io.nfg.core.pathfinding.AStar._buffY));
    if (!grid[io.nfg.core.pathfinding.AStar._buffY][io.nfg.core.pathfinding.AStar._buffX])
      result.push(new io.nfg.core.pathfinding.AStarNode(io.nfg.core.pathfinding.AStar._buffX, io.nfg.core.pathfinding.AStar._buffY));
    if (!grid[io.nfg.core.pathfinding.AStar._buffY][n.x - dir.x])
      result.push(new io.nfg.core.pathfinding.AStarNode(n.x - dir.x, io.nfg.core.pathfinding.AStar._buffY));
    if (!grid[n.y - dir.y][io.nfg.core.pathfinding.AStar._buffX])
      result.push(new io.nfg.core.pathfinding.AStarNode(io.nfg.core.pathfinding.AStar._buffX, n.y - dir.y));
  }
  return result;
};


/**
 * @export
 * @param {io.nfg.core.Pos} a
 * @param {io.nfg.core.Pos} b
 * @return {number}
 */
io.nfg.core.pathfinding.AStar.euclidean = function(a, b) {
  return (b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y);
};


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
io.nfg.core.pathfinding.AStar.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'AStar', qName: 'io.nfg.core.pathfinding.AStar', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
io.nfg.core.pathfinding.AStar.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {return {};},
    accessors: function () {return {};},
    methods: function () {
      return {
        '|reach': { type: 'Vector.<io.nfg.core.Pos>', declaredBy: 'io.nfg.core.pathfinding.AStar', parameters: function () { return [  { index: 1, type: 'io.nfg.core.Pos', optional: false },{ index: 2, type: 'io.nfg.core.Pos', optional: false },{ index: 3, type: 'Array', optional: false },{ index: 4, type: 'Number', optional: true } ]; }},
        '|explore': { type: 'Vector.<io.nfg.core.Pos>', declaredBy: 'io.nfg.core.pathfinding.AStar', parameters: function () { return [  { index: 1, type: 'io.nfg.core.Pos', optional: false },{ index: 2, type: 'Number', optional: false },{ index: 3, type: 'Array', optional: false },{ index: 4, type: 'Number', optional: true } ]; }},
        '|euclidean': { type: 'Number', declaredBy: 'io.nfg.core.pathfinding.AStar', parameters: function () { return [  { index: 1, type: 'io.nfg.core.Pos', optional: false },{ index: 2, type: 'io.nfg.core.Pos', optional: false } ]; }}
      };
    }
  };
};