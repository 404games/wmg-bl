/**
 * Generated by Apache Royale Compiler from io/nfg/wmg/battle/helpers/BattleHelper.as
 * io.nfg.wmg.battle.helpers.BattleHelper
 *
 * @fileoverview
 *
 * @suppress {checkTypes|accessControls}
 */

goog.provide('io.nfg.wmg.battle.helpers.BattleHelper');

goog.require('io.nfg.core.Pos');
goog.require('io.nfg.core.pathfinding.AStar');
goog.require('io.nfg.core.pathfinding.Simple');
goog.require('io.nfg.wmg.battle.BattleLogic');
goog.require('io.nfg.wmg.battle.components.UnitData');
goog.require('io.nfg.wmg.battle.helpers.UnitHelper');
goog.require('io.nfg.wmg.models.SpecialTile');
goog.require('org.incubatio.Entity');
goog.require('org.incubatio.TileMap');



/**
 * @constructor
 */
io.nfg.wmg.battle.helpers.BattleHelper = function() {
};


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('io.nfg.wmg.battle.helpers.BattleHelper', io.nfg.wmg.battle.helpers.BattleHelper);


/**
 * @export
 * @param {io.nfg.core.Pos} tilePos
 * @param {number} dim
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
io.nfg.wmg.battle.helpers.BattleHelper.isOverlapping = function(tilePos, dim, x, y) {
  var /** @type {number} */ i;
  var /** @type {number} */ j;
  for (i = 0; i < dim; i++)
    for (j = 0; j < dim; j++)
      if (tilePos.x + i == x && tilePos.y + j == y)
        return true;
  return false;
};


/**
 * @export
 * @param {io.nfg.core.Pos} tilePos
 * @param {org.incubatio.TileMap} tileMap
 * @param {number} targetDim
 * @param {number} originDim
 * @return {Array}
 */
io.nfg.wmg.battle.helpers.BattleHelper.getTilesInContact = function(tilePos, tileMap, targetDim, originDim) {
  var /** @type {Array} */ result = org.apache.royale.utils.Language.Vector();
  var /** @type {number} */ i, /** @type {number} */ j, /** @type {number} */ k, /** @type {number} */ l, /** @type {number} */ x, /** @type {number} */ y;
  var /** @type {org.incubatio.Entity} */ neighborEntity;
  for (i = -originDim; i <= targetDim; i++) {
    for (j = -originDim; j <= targetDim; j++) {
      x = tilePos.x + j;
      y = tilePos.y + i;
      if (io.nfg.wmg.battle.helpers.BattleHelper.isOverlapping(tilePos, targetDim, x, y) == false) {
        result.push(new io.nfg.core.Pos(x, y));
      }
    }
  }
  return result;
};


/**
 * @export
 * @param {io.nfg.core.Pos} tilePos
 * @param {org.incubatio.TileMap} tileMap
 * @param {number} targetDim
 * @param {number} originDim
 * @return {Array}
 */
io.nfg.wmg.battle.helpers.BattleHelper.getFreeTilesInContact = function(tilePos, tileMap, targetDim, originDim) {
  var /** @type {Array} */ tilesInContact = io.nfg.wmg.battle.helpers.BattleHelper.getTilesInContact(tilePos, tileMap, targetDim, originDim);
  var /** @type {io.nfg.core.Pos} */ tile;
  var /** @type {number} */ i;
  for (i = tilesInContact.length - 1; i > -1; i--) {
    tile = tilesInContact[i];
    if (tileMap.isOutOfUsableBounds(tile.x, tile.y) || tileMap.isOccupied(tile.x, tile.y, originDim)) {
      tilesInContact.splice(i, 1);
    }
  }
  return tilesInContact;
};


/**
 * Gets units in contact with provided one
 * @asparam entity
 * @asparam unitMap
 * @asparam tileMap
 * @asparam (optional) pIndex of the unit in contact, every unit if not precised.
 * @asreturn
 * @export
 * @param {org.incubatio.Entity} entity
 * @param {io.nfg.core.Pos} targetPos
 * @param {Array} unitMap
 * @param {org.incubatio.TileMap} tileMap
 * @param {number=} pIndex
 * @return {Array}
 */
io.nfg.wmg.battle.helpers.BattleHelper.getEntitiesInContact = function(entity, targetPos, unitMap, tileMap, pIndex) {
  pIndex = typeof pIndex !== 'undefined' ? pIndex : -1;
  var /** @type {number} */ dim = io.nfg.wmg.battle.helpers.UnitHelper.getDim(entity.getComponent(io.nfg.wmg.battle.components.UnitData));
  var /** @type {number} */ minX = targetPos.x > 1 ? targetPos.x - 1 : targetPos.x;
  var /** @type {number} */ maxX = dim == 1 ? targetPos.x + 1 : targetPos.x + 2;
  maxX = maxX > tileMap.cols ? tileMap.cols : maxX;
  var /** @type {number} */ minY = targetPos.y > 1 ? targetPos.y - 1 : targetPos.y;
  var /** @type {number} */ maxY = dim == 1 ? targetPos.y + 1 : targetPos.y + 2;
  maxY = maxY > tileMap.rows ? tileMap.rows : maxY;
  var /** @type {Array} */ inContact = org.apache.royale.utils.Language.Vector();
  var /** @type {number} */ gid;
  var /** @type {number} */ i;
  var /** @type {number} */ j;
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ unit2;
  for (i = minX; i <= maxX; i++) {
    for (j = minY; j <= maxY; j++) {
      gid = tileMap.tilePos2Gid(i, j);
      if (unitMap[gid] != null && unitMap[gid] != entity) {
        unit2 = unitMap[gid].getComponent(io.nfg.wmg.battle.components.UnitData);
        if (pIndex == -1 || unit2.get('pIndex') == pIndex) {
          if (inContact.indexOf(unitMap[gid]) < 0)
            inContact.push(unitMap[gid]);
        }
      }
    }
  }
  return inContact;
};


/**
 * @export
 * @param {string} targeting
 * @param {io.nfg.wmg.battle.BattleLogic} battle
 * @param {io.nfg.core.Pos} targetPos
 * @param {number=} fromGid
 * @param {Object=} options
 * @return {Array}
 */
io.nfg.wmg.battle.helpers.BattleHelper.getTargets = function(targeting, battle, targetPos, fromGid, options) {
  fromGid = typeof fromGid !== 'undefined' ? fromGid : -1;
  options = typeof options !== 'undefined' ? options : null;
  var /** @type {Array} */ unitMap = battle.unitMap;
  var /** @type {org.incubatio.TileMap} */ tileMap = battle.tileMap;
  var /** @type {number} */ pIndex = Number(battle.activeUnit.get('pIndex'));
  var /** @type {Array} */ applyTo;
  var /** @type {org.incubatio.Entity} */ targetEntity = battle.unitMap[tileMap.tilePos2Gid(targetPos.x, targetPos.y)];
  switch (targeting) {
    case 'all':
      applyTo = battle.aliveEntities.concat();
      break;
    case 'groups':
      applyTo = battle.aliveGroups[targetEntity.getComponent(io.nfg.wmg.battle.components.UnitData).get('pIndex')].concat();
      break;
    case 'allies':
      applyTo = battle.aliveGroups[pIndex].concat();
      break;
    case 'enemies':
      applyTo = battle.aliveGroups[battle.enemyIndex].concat();
      break;
    case 'anyinarea':
      applyTo = io.nfg.wmg.battle.helpers.BattleHelper.getUnitsInArea(targetPos, options.dim, unitMap, tileMap);
      break;
    case 'allyinarea':
      applyTo = io.nfg.wmg.battle.helpers.BattleHelper.getUnitsInArea(targetPos, options.dim, unitMap, tileMap, pIndex);
      break;
    case 'enemyinarea':
      applyTo = io.nfg.wmg.battle.helpers.BattleHelper.getUnitsInArea(targetPos, options.dim, unitMap, tileMap, battle.enemyIndex);
      break;
    case 'incontact':
      applyTo = io.nfg.wmg.battle.helpers.BattleHelper.getEntitiesInContact(battle.activeEntity, targetPos, unitMap, tileMap);
      break;
    case 'allyincontact':
      applyTo = io.nfg.wmg.battle.helpers.BattleHelper.getEntitiesInContact(battle.activeEntity, targetPos, unitMap, tileMap, pIndex);
      break;
    case 'enemyincontact':
      applyTo = io.nfg.wmg.battle.helpers.BattleHelper.getEntitiesInContact(battle.activeEntity, targetPos, unitMap, tileMap, battle.enemyIndex);
      break;
    case 'self':
      applyTo = [battle.activeEntity];
      break;
    case 'ally':
      applyTo = [];
      if (targetEntity) {
        var /** @type {io.nfg.wmg.battle.components.UnitData} */ unit = targetEntity.getComponent(io.nfg.wmg.battle.components.UnitData);
        if (unit.get('pIndex') == battle.activeUnit.get('pIndex'))
          applyTo.push(targetEntity);
      }
      break;
    case 'twotiles':
      applyTo = [targetEntity];
      var /** @type {io.nfg.core.Pos} */ dir = io.nfg.wmg.battle.helpers.BattleHelper.getDirectionVector(battle.tileMap.gid2TilePos(fromGid), targetPos);
      if (!tileMap.isOutOfBounds(targetPos.x + dir.x, targetPos.y + dir.y)) {
        var /** @type {number} */ targetGid = tileMap.tilePos2Gid(targetPos.x + dir.x, targetPos.y + dir.y);
        if (unitMap[targetGid] && unitMap[targetGid] != battle.activeEntity && targetEntity != unitMap[targetGid])
          applyTo.push(unitMap[targetGid]);
      }
      break;
    default:
      applyTo = org.apache.royale.utils.Language.Vector();
      if (targetEntity)
        applyTo.push(targetEntity);
  }
  return applyTo;
};


/**
 * @export
 * @param {io.nfg.core.Pos} tilePos
 * @param {number} dim
 * @param {Array} unitMap
 * @param {org.incubatio.TileMap} tileMap
 * @param {number=} pIndex
 * @return {Array}
 */
io.nfg.wmg.battle.helpers.BattleHelper.getUnitsInArea = function(tilePos, dim, unitMap, tileMap, pIndex) {
  pIndex = typeof pIndex !== 'undefined' ? pIndex : -1;
  if (dim < 2)
    dim = 2;
  var /** @type {number} */ minX = tilePos.x > 1 ? tilePos.x : 1;
  var /** @type {number} */ maxX = tilePos.x + dim < tileMap.cols ? tilePos.x + dim : tileMap.cols;
  var /** @type {number} */ minY = tilePos.y > 1 ? tilePos.y : 1;
  var /** @type {number} */ maxY = tilePos.y + dim < tileMap.rows ? tilePos.y + dim : tileMap.rows;
  var /** @type {Array} */ inContact = org.apache.royale.utils.Language.Vector();
  var /** @type {number} */ gid;
  var /** @type {number} */ i;
  var /** @type {number} */ j;
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ unit2;
  for (i = minX; i < maxX; i++) {
    for (j = minY; j < maxY; j++) {
      gid = tileMap.tilePos2Gid(i, j);
      if (unitMap[gid] != null) {
        unit2 = unitMap[gid].getComponent(io.nfg.wmg.battle.components.UnitData);
        if (pIndex == -1 || unit2.get('pIndex') == pIndex) {
          if (inContact.indexOf(unitMap[gid]) < 0)
            inContact.push(unitMap[gid]);
        }
      }
    }
  }
  return inContact;
};


/**
 * @export
 * @param {org.incubatio.Entity} entity
 * @param {io.nfg.core.Pos} to
 * @param {org.incubatio.TileMap} tileMap
 * @param {Array} tileInRange
 * @return {Array}
 */
io.nfg.wmg.battle.helpers.BattleHelper.unitMoveTo = function(entity, to, tileMap, tileInRange) {
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ unit = entity.getComponent(io.nfg.wmg.battle.components.UnitData);
  var /** @type {io.nfg.core.Pos} */ from = unit.tilePos;
  var /** @type {Array} */ path;
  var /** @type {number} */ movementRange = io.nfg.wmg.battle.helpers.UnitHelper.getMovementRange(unit);
  var /** @type {number} */ time;
  if (io.nfg.wmg.battle.helpers.UnitHelper.isTraversingObstacle(unit)) {
    path = [];
    if (!to.equals(from)) {
      path = io.nfg.core.pathfinding.Simple.reach(from, to, tileMap.collisionGrid[io.nfg.wmg.battle.helpers.UnitHelper.getDim(unit) - 1], tileInRange, movementRange);
    }
  } else {
    path = io.nfg.wmg.battle.helpers.BattleHelper.getPathTo(entity, to, tileMap, movementRange);
  }
  return path;
};


/**
 * @export
 * @param {org.incubatio.Entity} entity
 * @param {io.nfg.core.Pos} to
 * @param {org.incubatio.TileMap} tileMap
 * @param {number=} movementRange
 * @param {boolean=} avoidHole
 * @return {Array}
 */
io.nfg.wmg.battle.helpers.BattleHelper.getPathTo = function(entity, to, tileMap, movementRange, avoidHole) {
  movementRange = typeof movementRange !== 'undefined' ? movementRange : 0;
  avoidHole = typeof avoidHole !== 'undefined' ? avoidHole : false;
  var /** @type {Array} */ result;
  var /** @type {io.nfg.wmg.models.SpecialTile} */ specialTile1 = tileMap.getSpecialTile(to.x, to.y);
  var /** @type {io.nfg.wmg.models.SpecialTile} */ specialTile2;
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ unit = entity.getComponent(io.nfg.wmg.battle.components.UnitData);
  if (!specialTile1 || specialTile1.type != io.nfg.wmg.models.SpecialTile.HOLE)
    avoidHole = true;
  if (avoidHole && io.nfg.wmg.battle.helpers.UnitHelper.isTraversingObstacle(unit) == false)
    var foreachiter0_target = tileMap.specialTiles;
    for (var foreachiter0 in foreachiter0_target) 
    {
    specialTile2 = foreachiter0_target[foreachiter0];
    
      if (specialTile2.type == io.nfg.wmg.models.SpecialTile.HOLE && specialTile1 != specialTile2)
        tileMap.setTileToOccupied(specialTile2.x, specialTile2.y, 2);}
    
  var /** @type {Array} */ collisionGrid = tileMap.collisionGrid[io.nfg.wmg.battle.helpers.UnitHelper.getDim(unit) - 1];
  result = io.nfg.core.pathfinding.AStar.reach(unit.tilePos, to, collisionGrid, movementRange);
  if (avoidHole && io.nfg.wmg.battle.helpers.UnitHelper.isTraversingObstacle(unit) == false)
    var foreachiter1_target = tileMap.specialTiles;
    for (var foreachiter1 in foreachiter1_target) 
    {
    specialTile2 = foreachiter1_target[foreachiter1];
    
      if (specialTile2.type == io.nfg.wmg.models.SpecialTile.HOLE && specialTile1 != specialTile2)
        tileMap.setTileToFree(specialTile2.x, specialTile2.y, 2);}
    
  return result;
};


/**
 * @export
 * @param {io.nfg.wmg.battle.components.UnitData} unit
 * @param {org.incubatio.TileMap} tileMap
 * @param {boolean=} avoidHole
 * @return {Array}
 */
io.nfg.wmg.battle.helpers.BattleHelper.getRangeArea = function(unit, tileMap, avoidHole) {
  avoidHole = typeof avoidHole !== 'undefined' ? avoidHole : false;
  var /** @type {boolean} */ ignoreObstacles = io.nfg.wmg.battle.helpers.UnitHelper.isTraversingObstacle(unit);
  var /** @type {Array} */ collisionGrid = tileMap.collisionGrid[unit.dim - 1];
  var /** @type {number} */ range = io.nfg.wmg.battle.helpers.UnitHelper.getMovementRange(unit);
  var /** @type {Array} */ area;
  var /** @type {io.nfg.wmg.models.SpecialTile} */ specialTile;
  if (ignoreObstacles) {
    if (unit.type == 'evolutionist')
      var foreachiter2_target = tileMap.specialTiles;
      for (var foreachiter2 in foreachiter2_target) 
      {
      specialTile = foreachiter2_target[foreachiter2];
      
        if (specialTile.type == io.nfg.wmg.models.SpecialTile.HOLE)
          tileMap.setTileToOccupied(specialTile.x, specialTile.y, 2);}
      
    area = io.nfg.core.pathfinding.Simple.explore(unit.tilePos, range, collisionGrid);
    if (unit.type == 'evolutionist')
      var foreachiter3_target = tileMap.specialTiles;
      for (var foreachiter3 in foreachiter3_target) 
      {
      specialTile = foreachiter3_target[foreachiter3];
      
        if (specialTile.type == io.nfg.wmg.models.SpecialTile.HOLE)
          tileMap.setTileToFree(specialTile.x, specialTile.y, 2);}
      
  } else {
    var /** @type {io.nfg.core.Pos} */ point;
    if (avoidHole)
      var foreachiter4_target = tileMap.specialTiles;
      for (var foreachiter4 in foreachiter4_target) 
      {
      specialTile = foreachiter4_target[foreachiter4];
      
        if (specialTile.type == io.nfg.wmg.models.SpecialTile.HOLE)
          tileMap.setTileToOccupied(specialTile.x, specialTile.y, 2);}
      
    area = io.nfg.core.pathfinding.AStar.explore(unit.tilePos, range, collisionGrid, io.nfg.wmg.battle.helpers.UnitHelper.getDim(unit));
    if (avoidHole)
      var foreachiter5_target = tileMap.specialTiles;
      for (var foreachiter5 in foreachiter5_target) 
      {
      specialTile = foreachiter5_target[foreachiter5];
      
        if (specialTile.type == io.nfg.wmg.models.SpecialTile.HOLE)
          tileMap.setTileToFree(specialTile.x, specialTile.y, 2);}
      
  }
  return area;
};


/**
 * @export
 * @param {org.incubatio.Entity} originEntity
 * @param {Array} tilesInRangeMap
 * @param {Array} entities
 * @param {org.incubatio.TileMap} tileMap
 * @return {Array}
 */
io.nfg.wmg.battle.helpers.BattleHelper.getEnemiesInAttackRange = function(originEntity, tilesInRangeMap, entities, tileMap) {
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ originUnit = originEntity.getComponent(io.nfg.wmg.battle.components.UnitData);
  var /** @type {org.incubatio.Entity} */ targetEntity;
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ targetUnit;
  var /** @type {io.nfg.core.Pos} */ from = originUnit.tilePos;
  var /** @type {io.nfg.core.Pos} */ to;
  var /** @type {Array} */ grid = tileMap.collisionGrid[io.nfg.wmg.battle.helpers.UnitHelper.getDim(originUnit) - 1];
  var /** @type {number} */ squaredAttackRange = Math.pow(io.nfg.wmg.battle.helpers.UnitHelper.getMovementRange(originUnit) + 3, 2);
  var /** @type {io.nfg.core.Pos} */ tile;
  var /** @type {Array} */ result = [];
  var foreachiter6_target = entities;
  for (var foreachiter6 in foreachiter6_target) 
  {
  targetEntity = foreachiter6_target[foreachiter6];
  {
    targetUnit = targetEntity.getComponent(io.nfg.wmg.battle.components.UnitData);
    to = targetUnit.tilePos;
    if (io.nfg.core.pathfinding.AStar.euclidean(from, to) <= squaredAttackRange) {
      var foreachiter7_target = io.nfg.wmg.battle.helpers.BattleHelper.getTilesInContact(to, tileMap, io.nfg.wmg.battle.helpers.UnitHelper.getDim(targetUnit), io.nfg.wmg.battle.helpers.UnitHelper.getDim(originUnit));
      for (var foreachiter7 in foreachiter7_target) 
      {
      tile = foreachiter7_target[foreachiter7];
      {
        if (originUnit.tilePos.equals(tile) || tileMap.isOutOfUsableBounds(tile.x, tile.y) == false && tilesInRangeMap[tileMap.tilePos2Gid(tile.x, tile.y)]) {
          result.push(targetEntity);
          break;
        }
      }}
      
    }
  }}
  
  return result;
};


/**
 * @export
 * @param {org.incubatio.Entity} originEntity
 * @param {Array} tilesInRangeMap
 * @param {Array} entities
 * @param {org.incubatio.TileMap} tileMap
 * @return {Array}
 */
io.nfg.wmg.battle.helpers.BattleHelper.getEnemiesInContact = function(originEntity, tilesInRangeMap, entities, tileMap) {
  var /** @type {Array} */ result = org.apache.royale.utils.Language.Vector();
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ unit1 = originEntity.getComponent(io.nfg.wmg.battle.components.UnitData);
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ unit2;
  var /** @type {org.incubatio.Entity} */ entity;
  var foreachiter8_target = entities;
  for (var foreachiter8 in foreachiter8_target) 
  {
  entity = foreachiter8_target[foreachiter8];
  {
    unit2 = entity.getComponent(io.nfg.wmg.battle.components.UnitData);
    if (originEntity != entity && io.nfg.wmg.battle.helpers.BattleHelper.isUnitInContact(unit1, unit2, tileMap)) {
      result.push(entity);
    }
  }}
  
  return result;
};


/**
 * @export
 * @param {io.nfg.wmg.battle.components.UnitData} unit1
 * @param {io.nfg.wmg.battle.components.UnitData} unit2
 * @param {org.incubatio.TileMap} tileMap
 * @return {boolean}
 */
io.nfg.wmg.battle.helpers.BattleHelper.isUnitInContact = function(unit1, unit2, tileMap) {
  var /** @type {number} */ i;
  var /** @type {number} */ j;
  var /** @type {number} */ dim = io.nfg.wmg.battle.helpers.UnitHelper.getDim(unit1);
  var /** @type {io.nfg.core.Pos} */ pos = new io.nfg.core.Pos();
  for (i = 0; i < dim; i++) {
    for (j = 0; j < dim; j++) {
      pos.setTo(unit1.tilePos.x + i, unit1.tilePos.y + j);
      if (io.nfg.wmg.battle.helpers.BattleHelper.isTileInContact(pos, unit2, tileMap))
        return true;
    }
  }
  return false;
};


/**
 * @export
 * @param {io.nfg.core.Pos} tilePos
 * @param {io.nfg.wmg.battle.components.UnitData} unit
 * @param {org.incubatio.TileMap} tileMap
 * @return {boolean}
 */
io.nfg.wmg.battle.helpers.BattleHelper.isTileInContact = function(tilePos, unit, tileMap) {
  var /** @type {number} */ dim = io.nfg.wmg.battle.helpers.UnitHelper.getDim(unit);
  var /** @type {number} */ minX = unit.tilePos.x > 1 ? unit.tilePos.x - 1 : unit.tilePos.x;
  var /** @type {number} */ maxX = dim == 1 ? unit.tilePos.x + 1 : unit.tilePos.x + 2;
  maxX = maxX > tileMap.cols ? tileMap.cols : maxX;
  var /** @type {number} */ minY = unit.tilePos.y > 1 ? unit.tilePos.y - 1 : unit.tilePos.y;
  var /** @type {number} */ maxY = dim == 1 ? unit.tilePos.y + 1 : unit.tilePos.y + 2;
  maxY = maxY > tileMap.rows ? tileMap.rows : maxY;
  var /** @type {number} */ i;
  var /** @type {number} */ j;
  for (i = minX; i <= maxX; i++) {
    if (i != tilePos.x)
      continue;
    for (j = minY; j <= maxY; j++) {
      if (j == tilePos.y)
        return true;
    }
  }
  return false;
};


/**
 * @export
 * @param {io.nfg.wmg.battle.components.UnitData} unitData
 * @param {org.incubatio.Entity} target
 * @param {Array} unitMap
 * @param {org.incubatio.TileMap} tileMap
 * @return {boolean}
 */
io.nfg.wmg.battle.helpers.BattleHelper.unitIsNextTo = function(unitData, target, unitMap, tileMap) {
  var /** @type {number} */ i, /** @type {number} */ j;
  for (i = -1; i <= io.nfg.wmg.battle.helpers.UnitHelper.getDim(unitData); i++) {
    for (j = -1; j <= io.nfg.wmg.battle.helpers.UnitHelper.getDim(unitData); j++) {
      if (unitMap[(unitData.tilePos.y + i) * tileMap.cols + unitData.tilePos.x + j] != null)
        if (target == unitMap[(unitData.tilePos.y + i) * tileMap.cols + unitData.tilePos.x + j]) {
          return true;
        }
    }
  }
  return false;
};


/**
 * @export
 * @param {io.nfg.wmg.battle.components.UnitData} unitData
 * @param {Array} unitMap
 * @param {org.incubatio.TileMap} tileMap
 * @return {boolean}
 */
io.nfg.wmg.battle.helpers.BattleHelper.hasEnemyNeighbour = function(unitData, unitMap, tileMap) {
  var /** @type {number} */ i, /** @type {number} */ j;
  var /** @type {org.incubatio.Entity} */ neighborEntity;
  for (i = -1; i <= io.nfg.wmg.battle.helpers.UnitHelper.getDim(unitData); i++) {
    for (j = -1; j <= io.nfg.wmg.battle.helpers.UnitHelper.getDim(unitData); j++) {
      neighborEntity = unitMap[(unitData.tilePos.y + i) * tileMap.cols + unitData.tilePos.x + j];
      if (neighborEntity && neighborEntity.getComponent(io.nfg.wmg.battle.components.UnitData).get('pIndex') != unitData.get('pIndex')) {
        return true;
      }
    }
  }
  return false;
};


/**
 * @export
 * @param {Array} tilesInRange
 * @param {org.incubatio.TileMap} tileMap
 * @return {Array}
 */
io.nfg.wmg.battle.helpers.BattleHelper.createRangeAreaMap = function(tilesInRange, tileMap) {
  var /** @type {Array} */ r = org.apache.royale.utils.Language.Vector(tileMap.cols * tileMap.rows, 'Boolean'), /** @type {number} */ l = tilesInRange.length;
  for (var /** @type {number} */ i = 0; i < l; i++) {
    r[tileMap.tilePos2Gid(tilesInRange[i].x, tilesInRange[i].y)] = true;
  }
  return r;
};


/**
 * @export
 * @param {org.incubatio.Entity} entity
 * @param {Array} unitMap
 * @param {number} cols
 * @param {number=} dim
 */
io.nfg.wmg.battle.helpers.BattleHelper.placeUnitOnMap = function(entity, unitMap, cols, dim) {
  dim = typeof dim !== 'undefined' ? dim : 1;
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ unitData = entity.getComponent(io.nfg.wmg.battle.components.UnitData);
  unitMap[unitData.tilePos.y * cols + unitData.tilePos.x] = entity;
  if (unitData.dim > 1) {
    unitMap[unitData.tilePos.y * cols + unitData.tilePos.x + 1] = entity;
    unitMap[(unitData.tilePos.y + 1) * cols + unitData.tilePos.x] = entity;
    unitMap[(unitData.tilePos.y + 1) * cols + unitData.tilePos.x + 1] = entity;
  }
};


/**
 * @export
 * @param {org.incubatio.Entity} entity
 * @param {Array} unitMap
 * @param {number} cols
 */
io.nfg.wmg.battle.helpers.BattleHelper.removeUnitFromMap = function(entity, unitMap, cols) {
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ unitData = entity.getComponent(io.nfg.wmg.battle.components.UnitData);
  unitMap[unitData.tilePos.y * cols + unitData.tilePos.x] = null;
  if (unitData.dim > 1) {
    unitMap[(unitData.tilePos.y + 1) * cols + unitData.tilePos.x] = null;
    unitMap[(unitData.tilePos.y + 1) * cols + unitData.tilePos.x + 1] = null;
    unitMap[unitData.tilePos.y * cols + unitData.tilePos.x + 1] = null;
  }
};


/**
 * @export
 * @param {org.incubatio.Entity} entity
 * @param {number} col
 * @param {number} row
 * @param {Array} unitMap
 * @param {number} cols
 */
io.nfg.wmg.battle.helpers.BattleHelper.moveUnitOnMap = function(entity, col, row, unitMap, cols) {
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ unitData = entity.getComponent(io.nfg.wmg.battle.components.UnitData);
  if (unitData.tilePos.x == col && unitData.tilePos.y == row)
    return;
  io.nfg.wmg.battle.helpers.BattleHelper.removeUnitFromMap(entity, unitMap, cols);
  unitData.tilePos.x = col;
  unitData.tilePos.y = row;
  io.nfg.wmg.battle.helpers.BattleHelper.placeUnitOnMap(entity, unitMap, cols);
};


/**
 * @export
 * @param {org.incubatio.Entity} entity1
 * @param {org.incubatio.Entity} entity2
 * @param {Array} unitMap
 * @param {number} cols
 */
io.nfg.wmg.battle.helpers.BattleHelper.swapUnitsOnMap = function(entity1, entity2, unitMap, cols) {
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ unitData1 = entity1.getComponent(io.nfg.wmg.battle.components.UnitData);
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ unitData2 = entity2.getComponent(io.nfg.wmg.battle.components.UnitData);
  var /** @type {io.nfg.core.Pos} */ tilePos1 = unitData1.tilePos.clone();
  var /** @type {io.nfg.core.Pos} */ tilePos2 = unitData2.tilePos.clone();
  io.nfg.wmg.battle.helpers.BattleHelper.removeUnitFromMap(entity1, unitMap, cols);
  io.nfg.wmg.battle.helpers.BattleHelper.removeUnitFromMap(entity2, unitMap, cols);
  unitData1.tilePos.x = tilePos2.x;
  unitData1.tilePos.y = tilePos2.y;
  unitData2.tilePos.x = tilePos1.x;
  unitData2.tilePos.y = tilePos1.y;
  io.nfg.wmg.battle.helpers.BattleHelper.placeUnitOnMap(entity1, unitMap, cols);
  io.nfg.wmg.battle.helpers.BattleHelper.placeUnitOnMap(entity2, unitMap, cols);
};


/**
 * @export
 * @param {io.nfg.core.Pos} pos
 * @param {io.nfg.core.Pos} dest
 * @return {io.nfg.core.Pos}
 */
io.nfg.wmg.battle.helpers.BattleHelper.getDirectionVector = function(pos, dest) {
  var /** @type {io.nfg.core.Pos} */ r = new io.nfg.core.Pos((pos.x - dest.x > 0) ? -1 : 1, (pos.y - dest.y > 0) ? -1 : 1);
  if (pos.x == dest.x)
    r.x = 0;
  if (pos.y == dest.y)
    r.y = 0;
  return r;
};


/**
 * @export
 * @param {io.nfg.core.Pos} targetPos
 * @param {Array} rangeArea
 * @return {boolean}
 */
io.nfg.wmg.battle.helpers.BattleHelper.isTileInRange = function(targetPos, rangeArea) {
  var /** @type {boolean} */ inRange = false;
  var /** @type {io.nfg.core.Pos} */ tir;
  var foreachiter9_target = rangeArea;
  for (var foreachiter9 in foreachiter9_target) 
  {
  tir = foreachiter9_target[foreachiter9];
  {
    if (targetPos.equals(tir)) {
      inRange = true;
      break;
    }
  }}
  
  return inRange;
};


/**
 * @export
 * @param {io.nfg.wmg.battle.components.UnitData} unit
 * @param {org.incubatio.TileMap} tileMap
 * @return {boolean}
 */
io.nfg.wmg.battle.helpers.BattleHelper.isFlyingOnSpecialTile = function(unit, tileMap) {
  var /** @type {boolean} */ result = false;
  if (io.nfg.wmg.battle.helpers.UnitHelper.isFlying(unit)) {
    var /** @type {io.nfg.wmg.models.SpecialTile} */ specialTile;
    specialTile = tileMap.getSpecialTile(unit.tilePos.x, unit.tilePos.y, unit.dim);
    if (specialTile && specialTile.isFF == false)
      result = true;
  }
  return result;
};


/**
 * @export
 * @param {io.nfg.wmg.battle.components.UnitData} unit
 * @param {org.incubatio.TileMap} tileMap
 * @return {boolean}
 */
io.nfg.wmg.battle.helpers.BattleHelper.isOnHole = function(unit, tileMap) {
  var /** @type {io.nfg.wmg.models.SpecialTile} */ specialTile;
  specialTile = tileMap.getSpecialTile(unit.tilePos.x, unit.tilePos.y, unit.dim);
  return specialTile && specialTile.type == io.nfg.wmg.models.SpecialTile.HOLE;
};


/**
 * @export
 * @param {io.nfg.wmg.battle.BattleLogic} battle
 * @param {Array} logs
 */
io.nfg.wmg.battle.helpers.BattleHelper.replay = function(battle, logs) {
  var /** @type {Function} */ __localFn0__ = function(args) {
    args = Array.prototype.slice.call(arguments, 0);
    var /** @type {Function} */ __localFn0__ = function() {
    }
    if (logs.length > 0 && battle.didGameEnded(battle.activeUnit.get('pIndex')) == false) {
      battle.play.apply(battle, logs.shift());
      if (battle.isNextTurn && battle.isNextRound)
        battle.nextRound(__localFn0__);
      battle.isNextTurn ? battle.nextTurn(act) : act();
    }
  }
  var /** @type {Object} */ lvl;
  var /** @type {Function} */ act = __localFn0__;
  if (battle.isNextTurn && battle.isNextRound)
    battle.nextRound();
  battle.nextTurn(act);
};


/**
 * @export
 * @param {io.nfg.wmg.battle.BattleLogic} battle
 * @param {number} pIndex
 * @param {Object} unitConfs
 * @return {number}
 */
io.nfg.wmg.battle.helpers.BattleHelper.getXpBonus = function(battle, pIndex, unitConfs) {
  var /** @type {number} */ xpCount = 0;
  var /** @type {org.incubatio.Entity} */ entity;
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ unit;
  var /** @type {number} */ enemyIndex = pIndex == 0 ? 1 : 0;
  var foreachiter10_target = battle.deadGroups[enemyIndex];
  for (var foreachiter10 in foreachiter10_target) 
  {
  entity = foreachiter10_target[foreachiter10];
  {
    unit = entity.getComponent(io.nfg.wmg.battle.components.UnitData);
    xpCount += unitConfs.xp[unit.deckUnit.getLevel()] * io.nfg.wmg.battle.helpers.UnitHelper.getDim(unit);
  }}
  
  return Math.ceil(xpCount / battle.aliveGroups[pIndex].length);
};


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
io.nfg.wmg.battle.helpers.BattleHelper.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'BattleHelper', qName: 'io.nfg.wmg.battle.helpers.BattleHelper', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
io.nfg.wmg.battle.helpers.BattleHelper.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {return {};},
    accessors: function () {return {};},
    methods: function () {
      return {
        '|isOverlapping': { type: 'Boolean', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'io.nfg.core.Pos', optional: false },{ index: 2, type: 'Number', optional: false },{ index: 3, type: 'Number', optional: false },{ index: 4, type: 'Number', optional: false } ]; }},
        '|getTilesInContact': { type: 'Vector.<io.nfg.core.Pos>', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'io.nfg.core.Pos', optional: false },{ index: 2, type: 'org.incubatio.TileMap', optional: false },{ index: 3, type: 'Number', optional: false },{ index: 4, type: 'Number', optional: false } ]; }},
        '|getFreeTilesInContact': { type: 'Vector.<io.nfg.core.Pos>', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'io.nfg.core.Pos', optional: false },{ index: 2, type: 'org.incubatio.TileMap', optional: false },{ index: 3, type: 'Number', optional: false },{ index: 4, type: 'Number', optional: false } ]; }},
        '|getEntitiesInContact': { type: 'Vector.<org.incubatio.Entity>', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'org.incubatio.Entity', optional: false },{ index: 2, type: 'io.nfg.core.Pos', optional: false },{ index: 3, type: 'Array', optional: false },{ index: 4, type: 'org.incubatio.TileMap', optional: false },{ index: 5, type: 'Number', optional: true } ]; }},
        '|getTargets': { type: 'Vector.<org.incubatio.Entity>', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'String', optional: false },{ index: 2, type: 'io.nfg.wmg.battle.BattleLogic', optional: false },{ index: 3, type: 'io.nfg.core.Pos', optional: false },{ index: 4, type: 'Number', optional: true },{ index: 5, type: 'Object', optional: true } ]; }},
        '|getUnitsInArea': { type: 'Vector.<org.incubatio.Entity>', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'io.nfg.core.Pos', optional: false },{ index: 2, type: 'Number', optional: false },{ index: 3, type: 'Array', optional: false },{ index: 4, type: 'org.incubatio.TileMap', optional: false },{ index: 5, type: 'Number', optional: true } ]; }},
        '|unitMoveTo': { type: 'Vector.<io.nfg.core.Pos>', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'org.incubatio.Entity', optional: false },{ index: 2, type: 'io.nfg.core.Pos', optional: false },{ index: 3, type: 'org.incubatio.TileMap', optional: false },{ index: 4, type: 'Vector.<io.nfg.core.Pos>', optional: false } ]; }},
        '|getPathTo': { type: 'Vector.<io.nfg.core.Pos>', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'org.incubatio.Entity', optional: false },{ index: 2, type: 'io.nfg.core.Pos', optional: false },{ index: 3, type: 'org.incubatio.TileMap', optional: false },{ index: 4, type: 'Number', optional: true },{ index: 5, type: 'Boolean', optional: true } ]; }},
        '|getRangeArea': { type: 'Vector.<io.nfg.core.Pos>', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'io.nfg.wmg.battle.components.UnitData', optional: false },{ index: 2, type: 'org.incubatio.TileMap', optional: false },{ index: 3, type: 'Boolean', optional: true } ]; }},
        '|getEnemiesInAttackRange': { type: 'Vector.<org.incubatio.Entity>', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'org.incubatio.Entity', optional: false },{ index: 2, type: 'Vector.<Boolean>', optional: false },{ index: 3, type: 'Vector.<org.incubatio.Entity>', optional: false },{ index: 4, type: 'org.incubatio.TileMap', optional: false } ]; }},
        '|getEnemiesInContact': { type: 'Vector.<org.incubatio.Entity>', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'org.incubatio.Entity', optional: false },{ index: 2, type: 'Vector.<Boolean>', optional: false },{ index: 3, type: 'Vector.<org.incubatio.Entity>', optional: false },{ index: 4, type: 'org.incubatio.TileMap', optional: false } ]; }},
        '|isUnitInContact': { type: 'Boolean', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'io.nfg.wmg.battle.components.UnitData', optional: false },{ index: 2, type: 'io.nfg.wmg.battle.components.UnitData', optional: false },{ index: 3, type: 'org.incubatio.TileMap', optional: false } ]; }},
        '|isTileInContact': { type: 'Boolean', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'io.nfg.core.Pos', optional: false },{ index: 2, type: 'io.nfg.wmg.battle.components.UnitData', optional: false },{ index: 3, type: 'org.incubatio.TileMap', optional: false } ]; }},
        '|unitIsNextTo': { type: 'Boolean', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'io.nfg.wmg.battle.components.UnitData', optional: false },{ index: 2, type: 'org.incubatio.Entity', optional: false },{ index: 3, type: 'Array', optional: false },{ index: 4, type: 'org.incubatio.TileMap', optional: false } ]; }},
        '|hasEnemyNeighbour': { type: 'Boolean', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'io.nfg.wmg.battle.components.UnitData', optional: false },{ index: 2, type: 'Array', optional: false },{ index: 3, type: 'org.incubatio.TileMap', optional: false } ]; }},
        '|createRangeAreaMap': { type: 'Vector.<Boolean>', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'Vector.<io.nfg.core.Pos>', optional: false },{ index: 2, type: 'org.incubatio.TileMap', optional: false } ]; }},
        '|placeUnitOnMap': { type: 'void', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'org.incubatio.Entity', optional: false },{ index: 2, type: 'Array', optional: false },{ index: 3, type: 'Number', optional: false },{ index: 4, type: 'Number', optional: true } ]; }},
        '|removeUnitFromMap': { type: 'void', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'org.incubatio.Entity', optional: false },{ index: 2, type: 'Array', optional: false },{ index: 3, type: 'Number', optional: false } ]; }},
        '|moveUnitOnMap': { type: 'void', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'org.incubatio.Entity', optional: false },{ index: 2, type: 'Number', optional: false },{ index: 3, type: 'Number', optional: false },{ index: 4, type: 'Array', optional: false },{ index: 5, type: 'Number', optional: false } ]; }},
        '|swapUnitsOnMap': { type: 'void', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'org.incubatio.Entity', optional: false },{ index: 2, type: 'org.incubatio.Entity', optional: false },{ index: 3, type: 'Array', optional: false },{ index: 4, type: 'Number', optional: false } ]; }},
        '|getDirectionVector': { type: 'io.nfg.core.Pos', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'io.nfg.core.Pos', optional: false },{ index: 2, type: 'io.nfg.core.Pos', optional: false } ]; }},
        '|isTileInRange': { type: 'Boolean', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'io.nfg.core.Pos', optional: false },{ index: 2, type: 'Vector.<io.nfg.core.Pos>', optional: false } ]; }},
        '|isFlyingOnSpecialTile': { type: 'Boolean', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'io.nfg.wmg.battle.components.UnitData', optional: false },{ index: 2, type: 'org.incubatio.TileMap', optional: false } ]; }},
        '|isOnHole': { type: 'Boolean', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'io.nfg.wmg.battle.components.UnitData', optional: false },{ index: 2, type: 'org.incubatio.TileMap', optional: false } ]; }},
        '|replay': { type: 'void', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'io.nfg.wmg.battle.BattleLogic', optional: false },{ index: 2, type: 'Array', optional: false } ]; }},
        '|getXpBonus': { type: 'Number', declaredBy: 'io.nfg.wmg.battle.helpers.BattleHelper', parameters: function () { return [  { index: 1, type: 'io.nfg.wmg.battle.BattleLogic', optional: false },{ index: 2, type: 'Number', optional: false },{ index: 3, type: 'Object', optional: false } ]; }}
      };
    }
  };
};