/**
 * Generated by Apache Royale Compiler from io/nfg/wmg/battle/BattleLogic.as
 * io.nfg.wmg.battle.BattleLogic
 *
 * @fileoverview
 *
 * @suppress {checkTypes|accessControls}
 */

goog.provide('io.nfg.wmg.battle.BattleLogic');
/* Royale Static Dependency List: io.nfg.wmg.battle.modes.Annihilation,io.nfg.wmg.battle.modes.Assassination,io.nfg.wmg.battle.modes.RoundAttack,io.nfg.wmg.battle.modes.StayAlive,io.nfg.wmg.battle.modes.RunAway,io.nfg.wmg.battle.modes.Peace,io.nfg.core.Tools,io.nfg.wmg.battle.BattleLogic*/

goog.require('io.nfg.core.Pos');
goog.require('io.nfg.core.Tools');
goog.require('io.nfg.wmg.battle.CombatsLogic');
goog.require('io.nfg.wmg.battle.EntityFactory');
goog.require('io.nfg.wmg.battle.Mechanics');
goog.require('io.nfg.wmg.battle.SpecialsLogic');
goog.require('io.nfg.wmg.battle.SpellsLogic');
goog.require('io.nfg.wmg.battle.StatusesLogic');
goog.require('io.nfg.wmg.battle.components.UnitData');
goog.require('io.nfg.wmg.battle.helpers.BattleHelper');
goog.require('io.nfg.wmg.battle.helpers.StatusHelper');
goog.require('io.nfg.wmg.battle.helpers.UnitHelper');
goog.require('io.nfg.wmg.battle.modes.AGameMode');
goog.require('io.nfg.wmg.battle.modes.Annihilation');
goog.require('io.nfg.wmg.battle.modes.Assassination');
goog.require('io.nfg.wmg.battle.modes.Peace');
goog.require('io.nfg.wmg.battle.modes.RoundAttack');
goog.require('io.nfg.wmg.battle.modes.RunAway');
goog.require('io.nfg.wmg.battle.modes.StayAlive');
goog.require('io.nfg.wmg.models.Actor');
goog.require('io.nfg.wmg.models.DeckUnit');
goog.require('io.nfg.wmg.models.Map');
goog.require('io.nfg.wmg.models.Mission');
goog.require('io.nfg.wmg.models.PlayerTypes');
goog.require('io.nfg.wmg.models.SpecialTile');
goog.require('org.incubatio.Entity');
goog.require('org.incubatio.TileMap');
goog.require('org.apache.royale.utils.Language');



/**
 * @constructor
 * @param {Array} entities
 * @param {Array} actors
 * @param {org.incubatio.TileMap} tileMap
 * @param {Array} objectives
 * @param {Object} configs
 */
io.nfg.wmg.battle.BattleLogic = function(entities, actors, tileMap, objectives, configs) {
  
  this._playerTypes = {};
  this._allGroups = {};
  this._aliveGroups = {};
  this._deadGroups = {};
  this._unitMap = [];
  this._configs = configs;
  this._aliveGroups = {};
  this._entities = entities;
  this._logs = [];
  this._tileMap = tileMap;
  this._aliveEntities = [];
  this.roundNumber = 0;
  this.addBattlelogEntry = org.apache.royale.utils.Language.closure(this._defaultAddBattlelogEntry, this, '_defaultAddBattlelogEntry');
  this.isNextTurn = true;
  if (!io.nfg.wmg.battle.BattleLogic.ACTION_NAMES) {
    io.nfg.wmg.battle.BattleLogic.ACTION_NAMES = {};
    io.nfg.wmg.battle.BattleLogic.ACTION_NAMES[io.nfg.wmg.battle.BattleLogic.MOVE] = "unitMove";
    io.nfg.wmg.battle.BattleLogic.ACTION_NAMES[io.nfg.wmg.battle.BattleLogic.ATTACK] = "unitAttack";
    io.nfg.wmg.battle.BattleLogic.ACTION_NAMES[io.nfg.wmg.battle.BattleLogic.SPECIAL] = "unitSpecial";
    io.nfg.wmg.battle.BattleLogic.ACTION_NAMES[io.nfg.wmg.battle.BattleLogic.SPELL] = "spell";
    io.nfg.wmg.battle.BattleLogic.ACTION_NAMES[io.nfg.wmg.battle.BattleLogic.SKIP] = "unitSkip";
  }
  var /** @type {number} */ i;
  var /** @type {string} */ name;
  var /** @type {org.incubatio.Entity} */ entity;
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ unit;
  var /** @type {io.nfg.wmg.models.Actor} */ actor;
  for (i in actors) {
    actor = actors[i];
    io.nfg.wmg.battle.BattleLogic._log(i + ' type:', io.nfg.wmg.models.PlayerTypes.getNameById(actor.get('type')));
    this._playerTypes[i] = actor.get('type');
  }
  for (i in actors) {
    this._allGroups[i + "_aliveEntities"] = this._aliveGroups[i] = [];
    this._allGroups[i + "_deadUnits"] = this._deadGroups[i] = [];
  }
  var foreachiter0_target = this._entities;
  for (var foreachiter0 in foreachiter0_target) 
  {
  entity = foreachiter0_target[foreachiter0];
  {
    io.nfg.wmg.battle.BattleLogic._log("    " + entity.getComponent(io.nfg.wmg.battle.components.UnitData).get('pIndex') + "  " + entity.toString());
    this._aliveGroups[entity.getComponent(io.nfg.wmg.battle.components.UnitData).get('pIndex')].push(entity);
    this._aliveEntities.push(entity);
    io.nfg.wmg.battle.helpers.StatusHelper.addStatus(entity, 'defended');
  }}
  
  this._allGroups["units"] = this._aliveEntities;
  this._allGroups["units_in_round"] = [];
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ unitData;
  for (i = 0; i < this._aliveEntities.length; i++) {
    unitData = this._aliveEntities[i].getComponent(io.nfg.wmg.battle.components.UnitData);
    io.nfg.wmg.battle.helpers.BattleHelper.placeUnitOnMap(this._aliveEntities[i], this._unitMap, this._tileMap.cols, io.nfg.wmg.battle.helpers.UnitHelper.getDim(unitData));
    this._tileMap.setTileToOccupied(unitData.tilePos.x, unitData.tilePos.y, io.nfg.wmg.battle.helpers.UnitHelper.getDim(unitData));
  }
  this.updateMeleePenaltyStatus();
  if (!objectives || objectives.length < 1)
    objectives = [{name:'annihilation', pIndex:0}];
  io.nfg.wmg.battle.BattleLogic._log('objective(s)', objectives);
  this._gameModes = [];
  var /** @type {Object} */ mode;
  var foreachiter1_target = objectives;
  for (var foreachiter1 in foreachiter1_target) 
  {
  mode = foreachiter1_target[foreachiter1];
  {
    this._gameModes.push(new io.nfg.wmg.battle.BattleLogic.MODES[mode.name](mode, this));
  }}
  
};


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('io.nfg.wmg.battle.BattleLogic', io.nfg.wmg.battle.BattleLogic);


/**
 * @private
 * @const
 * @type {Object}
 */
io.nfg.wmg.battle.BattleLogic.MODES = {annihilation:io.nfg.wmg.battle.modes.Annihilation, assassination:io.nfg.wmg.battle.modes.Assassination, roundattack:io.nfg.wmg.battle.modes.RoundAttack, stayalive:io.nfg.wmg.battle.modes.StayAlive, runaway:io.nfg.wmg.battle.modes.RunAway, peace:io.nfg.wmg.battle.modes.Peace};


/**
 * @export
 * @type {Object}
 */
io.nfg.wmg.battle.BattleLogic.ACTION_NAMES;


/**
 * @export
 * @const
 * @type {number}
 */
io.nfg.wmg.battle.BattleLogic.MOVE = 1;


/**
 * @export
 * @const
 * @type {number}
 */
io.nfg.wmg.battle.BattleLogic.ATTACK = 2;


/**
 * @export
 * @const
 * @type {number}
 */
io.nfg.wmg.battle.BattleLogic.SPECIAL = 3;


/**
 * @export
 * @const
 * @type {number}
 */
io.nfg.wmg.battle.BattleLogic.SPELL = 4;


/**
 * @export
 * @const
 * @type {number}
 */
io.nfg.wmg.battle.BattleLogic.SKIP = 5;


/**
 * @export
 * @const
 * @type {number}
 */
io.nfg.wmg.battle.BattleLogic.EXCEPTION = 8;


/**
 * @private
 * @type {Object}
 */
io.nfg.wmg.battle.BattleLogic.prototype._playerTypes;


/**
 * @private
 * @type {Array}
 */
io.nfg.wmg.battle.BattleLogic.prototype._gameModes;


/**
 * @private
 * @type {Array}
 */
io.nfg.wmg.battle.BattleLogic.prototype._entities;


/**
 * @private
 * @type {Object}
 */
io.nfg.wmg.battle.BattleLogic.prototype._allGroups;


/**
 * @private
 * @type {Array}
 */
io.nfg.wmg.battle.BattleLogic.prototype._aliveEntities;


/**
 * @private
 * @type {Object}
 */
io.nfg.wmg.battle.BattleLogic.prototype._aliveGroups;


/**
 * @private
 * @type {Object}
 */
io.nfg.wmg.battle.BattleLogic.prototype._deadGroups;


/**
 * @private
 * @type {Object}
 */
io.nfg.wmg.battle.BattleLogic.prototype._configs;


/**
 * @private
 * @type {org.incubatio.TileMap}
 */
io.nfg.wmg.battle.BattleLogic.prototype._tileMap;


/**
 * @private
 * @type {Array}
 */
io.nfg.wmg.battle.BattleLogic.prototype._unitMap;


/**
 * @private
 * @type {Array}
 */
io.nfg.wmg.battle.BattleLogic.prototype._tilesInRange;


/**
 * @private
 * @type {Array}
 */
io.nfg.wmg.battle.BattleLogic.prototype._tilesInRangeMap;


/**
 * @private
 * @type {Array}
 */
io.nfg.wmg.battle.BattleLogic.prototype._attackableEnemies;


/**
 * @private
 * @type {org.incubatio.Entity}
 */
io.nfg.wmg.battle.BattleLogic.prototype._activeEntity;


/**
 * @private
 * @type {io.nfg.wmg.battle.components.UnitData}
 */
io.nfg.wmg.battle.BattleLogic.prototype._activeUnit;


/**
 * @private
 * @type {boolean}
 */
io.nfg.wmg.battle.BattleLogic.prototype._activeUnitHasEnemyNeighbour;


/**
 * @export
 * @type {number}
 */
io.nfg.wmg.battle.BattleLogic.prototype.enemyIndex;


/**
 * @export
 * @type {number}
 */
io.nfg.wmg.battle.BattleLogic.prototype.roundNumber;


/**
 * @export
 * @type {boolean}
 */
io.nfg.wmg.battle.BattleLogic.prototype.isNextTurn;


/**
 * @private
 * @type {Array}
 */
io.nfg.wmg.battle.BattleLogic.prototype._logs;


/**
 * @export
 * @type {Function}
 */
io.nfg.wmg.battle.BattleLogic.prototype.addBattlelogEntry;


/**
 * @private
 * @type {Function}
 */
io.nfg.wmg.battle.BattleLogic._log;


/**
 * @private
 * @type {Function}
 */
io.nfg.wmg.battle.BattleLogic._plog;


/**
 * @private
 * @type {Function}
 */
io.nfg.wmg.battle.BattleLogic._logStatus;


/**
 * @export
 * @param {io.nfg.wmg.models.Mission} mission
 * @param {Object} configs
 * @return {io.nfg.wmg.battle.BattleLogic}
 */
io.nfg.wmg.battle.BattleLogic.fromMission = function(mission, configs) {
  var /** @type {io.nfg.wmg.models.Map} */ map = mission.get('map');
  var /** @type {Array} */ size = [map.get('collisions')[0].length, map.get('collisions').length];
  var /** @type {org.incubatio.TileMap} */ tileMap = new org.incubatio.TileMap(size[0], size[1], {});
  var /** @type {number} */ i, /** @type {number} */ j, /** @type {Array} */ line;
  for (i = 0; i < size[1]; i++) {
    line = map.get('collisions')[i].split("");
    for (j = 0; j < size[0]; j++) {
      if (line[j] == "W") {
        tileMap.setTileToOccupied(j, i, 1, 10000);
      } else if (isNaN(line[j]) == false) {
        tileMap.setTileToOccupied(j, i, Number(line[j]), 10000);
      } else if (line[j] != ".") {
        tileMap.setSpecialTile(j, i, line[j]);
      }
    }
  }
  var /** @type {io.nfg.wmg.models.Actor} */ actor;
  var /** @type {io.nfg.wmg.models.DeckUnit} */ deckUnit;
  var /** @type {number} */ dim;
  var /** @type {boolean} */ matched;
  var foreachiter2_target = mission.get('actors');
  for (var foreachiter2 in foreachiter2_target) 
  {
  actor = foreachiter2_target[foreachiter2];
  {
    if (actor.get('deck').length < 1)
      throw new Error('can\'t init a BattleLogic with empty deck');
    if (actor.get('deck')[0].get('pos'))
      continue;
    var foreachiter3_target = actor.get('deck');
    for (var foreachiter3 in foreachiter3_target) 
    {
    deckUnit = foreachiter3_target[foreachiter3];
    {
      dim = Number(io.nfg.wmg.battle.helpers.UnitHelper["unitsConfig"][deckUnit.get('type')]["size"]);
      matched = false;
      for (j = 1; j < 4; j++) {
        for (i = 1; i < size[1] - 1; i++) {
          if (tileMap.isOccupied(j, i, dim) == false) {
            deckUnit.set('pos', [j, i]);
            tileMap.setTileToOccupied(j, i, dim);
            matched = true;
            break;
          }
          if (matched)
            break;
        }
        if (matched)
          break;
      }
    }}
    
    var foreachiter4_target = actor.get('deck');
    for (var foreachiter4 in foreachiter4_target) 
    {
    deckUnit = foreachiter4_target[foreachiter4];
    {
      dim = Number(io.nfg.wmg.battle.helpers.UnitHelper["unitsConfig"][deckUnit.get('type')]["size"]);
      tileMap.setTileToFree(deckUnit.get('pos')[0], deckUnit.get('pos')[1], dim);
    }}
    
  }}
  
  var /** @type {Array} */ entities = io.nfg.wmg.battle.EntityFactory.createEntitiesFromConfig(mission.get('actors'), tileMap);
  return new io.nfg.wmg.battle.BattleLogic(entities, mission.get('actors'), tileMap, mission.get('objectives'), configs);
};


/**
 * @export
 */
io.nfg.wmg.battle.BattleLogic.prototype.clearUnits = function() {
  while (this._aliveEntities.length != 0) {
    this._unitRemove(this._aliveEntities[0]);
  }
  this._unitMap = [];
};


/**
 * @export
 * @param {Function=} cb
 */
io.nfg.wmg.battle.BattleLogic.prototype.nextRound = function(cb) {
  cb = typeof cb !== 'undefined' ? cb : null;
  io.nfg.wmg.battle.BattleLogic._log("[NEXT ROUND], number", ++this.roundNumber, this._aliveEntities);
  this._allGroups["units_in_round"] = this._aliveEntities.concat();
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ unitData;
  var /** @type {Object} */ status;
  var /** @type {string} */ special;
  for (var /** @type {number} */ i = 0; i < this._allGroups["units_in_round"].length; i++) {
    unitData = this._allGroups["units_in_round"][i].getComponent(io.nfg.wmg.battle.components.UnitData);
    unitData.set('hasWaited', false);
    unitData.set('hasMoved', false);
    unitData.set('riposteDoneNum', 0);
    var /** @type {Object} */ scds = unitData.get('specialCooldowns');
    for (special in scds)
      if (scds[special] > 0)
        scds[special]--;
    var foreachiter5_target = unitData.get('statuses');
    for (var foreachiter5 in foreachiter5_target) 
    {
    status = foreachiter5_target[foreachiter5];
    
      status.incremented = false;}
    
  }
  this._allGroups["units_in_round"].sort(org.apache.royale.utils.Language.closure(this.sortUnits, this, 'sortUnits'));
  if (cb)
    cb();
};


/**
 * @export
 * @param {number} pIndex
 * @return {boolean}
 */
io.nfg.wmg.battle.BattleLogic.prototype.didGameEnded = function(pIndex) {
  var /** @type {io.nfg.wmg.battle.modes.AGameMode} */ mode;
  var /** @type {boolean} */ result = false;
  var /** @type {Object} */ groups = {};
  var foreachiter6_target = this._gameModes;
  for (var foreachiter6 in foreachiter6_target) 
  {
  mode = foreachiter6_target[foreachiter6];
  {
    if (groups[mode.group] == undefined)
      groups[mode.group] = false;
    if (mode.didGameEnded(pIndex))
      groups[mode.group] = true;
  }}
  
  var /** @type {boolean} */ group;
  var foreachiter7_target = groups;
  for (var foreachiter7 in foreachiter7_target) 
  {
  group = foreachiter7_target[foreachiter7];
  {
    if (group) {
      result = true;
      break;
    }
  }}
  
  io.nfg.wmg.battle.BattleLogic._log('didGameEnded', result);
  return result;
};


/**
 * @export
 * @param {Function} cb
 */
io.nfg.wmg.battle.BattleLogic.prototype.nextTurn = function(cb) {
  io.nfg.wmg.battle.BattleLogic._log("[NEXT TURN]");
  this.isNextTurn = false;
  if (this._activeUnit != null && io.nfg.wmg.battle.helpers.UnitHelper.getHealth(this._activeUnit) > 0)
    this._tileMap.setTileToOccupied(this._activeUnit.tilePos.x, this._activeUnit.tilePos.y, io.nfg.wmg.battle.helpers.UnitHelper.getDim(this._activeUnit));
  var /** @type {org.incubatio.Entity} */ entity;
  var /** @type {Object} */ status;
  var foreachiter8_target = this.aliveEntities;
  for (var foreachiter8 in foreachiter8_target) 
  {
  entity = foreachiter8_target[foreachiter8];
  {
    var foreachiter9_target = entity.getComponent(io.nfg.wmg.battle.components.UnitData).get('statuses');
    for (var foreachiter9 in foreachiter9_target) 
    {
    status = foreachiter9_target[foreachiter9];
    {
      io.nfg.wmg.battle.BattleLogic._logStatus("status", entity.toString(), status.name, status.duration);
      if (status.duration == 0)
        io.nfg.wmg.battle.helpers.StatusHelper.removeStatus(entity, status.name);
    }}
    
  }}
  
  this._activeEntity = this._allGroups["units_in_round"].shift();
  if (this._activeEntity) {
    this._activeUnit = this._activeEntity.getComponent(io.nfg.wmg.battle.components.UnitData);
    io.nfg.wmg.battle.BattleLogic._log("    " + ['left', 'right'][this._activeUnit.get('pIndex')] + "'s Turn ! " + this._activeUnit.type + "'s playin'");
    var foreachiter10_target = this._activeUnit.get('statuses');
    for (var foreachiter10 in foreachiter10_target) 
    {
    status = foreachiter10_target[foreachiter10];
    {
      if (status.incremented != true) {
        io.nfg.wmg.battle.BattleLogic._logStatus("status", this._activeUnit.type, status.name, status.duration);
        if (status.duration > 0)
          status.duration--;
        if (status.duration == 0)
          io.nfg.wmg.battle.helpers.StatusHelper.removeStatus(this._activeEntity, status.name);
      }
    }}
    
    io.nfg.wmg.battle.StatusesLogic.play(this);
    this._tileMap.setTileToFree(this._activeUnit.tilePos.x, this._activeUnit.tilePos.y, io.nfg.wmg.battle.helpers.UnitHelper.getDim(this._activeUnit));
    this.enemyIndex = this._activeUnit.get('pIndex') == 0 ? 1 : 0;
    this._updateUnitSurrounding();
    io.nfg.wmg.battle.BattleLogic._logStatus("UNIT STATUSES", this._activeUnit.type, this._activeUnit.get('statuses'));
    if (io.nfg.wmg.battle.helpers.UnitHelper.isDead(this._activeUnit))
      this.isNextTurn = true;
  }
  cb();
};


/**
 * @private
 */
io.nfg.wmg.battle.BattleLogic.prototype._updateUnitSurrounding = function() {
  if (this._activeUnit.get('hasMoved')) {
    this.tilesInRangeMap.length = 0;
    this.tilesInRangeMap.length = this._tileMap.cols * this._tileMap.rows;
    this.tilesInRange.length = 0;
  } else {
    this._tilesInRange = io.nfg.wmg.battle.helpers.BattleHelper.getRangeArea(this._activeUnit, this._tileMap);
    this._tilesInRangeMap = io.nfg.wmg.battle.helpers.BattleHelper.createRangeAreaMap(this._tilesInRange, this._tileMap);
  }
  this._activeUnitHasEnemyNeighbour = io.nfg.wmg.battle.helpers.BattleHelper.hasEnemyNeighbour(this._activeUnit, this._unitMap, this._tileMap);
  if (io.nfg.wmg.battle.helpers.UnitHelper.isRanged(this._activeUnit) && this._activeUnitHasEnemyNeighbour == false)
    this._attackableEnemies = this._aliveGroups[this.enemyIndex];
  else
    this._attackableEnemies = io.nfg.wmg.battle.helpers.BattleHelper.getEnemiesInContact(this._activeEntity, this._tilesInRangeMap, this._aliveGroups[this.enemyIndex], this._tileMap);
  var /** @type {Object} */ tauntStatus = io.nfg.wmg.battle.helpers.StatusHelper.getStatus(this._activeUnit, 'taunted');
  if (tauntStatus) {
    var /** @type {org.incubatio.Entity} */ entity;
    var foreachiter11_target = this._attackableEnemies;
    for (var foreachiter11 in foreachiter11_target) 
    {
    entity = foreachiter11_target[foreachiter11];
    {
      if (tauntStatus.originEntity == entity) {
        this._attackableEnemies = [];
        this._attackableEnemies.push(entity);
        break;
      }
    }}
    
  }
  io.nfg.wmg.battle.BattleLogic._log('enemy in range', this._attackableEnemies.length);
};


/**
 * @private
 * @param {number} type
 * @param {org.incubatio.Entity} target
 * @param {Object=} options
 */
io.nfg.wmg.battle.BattleLogic.prototype._defaultAddBattlelogEntry = function(type, target, options) {
  options = typeof options !== 'undefined' ? options : null;
  io.nfg.wmg.battle.BattleLogic._log("Please set addBattleLog function before new BattleLogic");
};


/**
 * @private
 * @param {string} e
 * @param {string=} type
 */
io.nfg.wmg.battle.BattleLogic.prototype._reportException = function(e, type) {
  type = typeof type !== 'undefined' ? type : "common";
  this.addBattlelogEntry(io.nfg.wmg.battle.BattleLogic.EXCEPTION, null, {message:e, type:type});
};


/**
 * @export
 * @param {number} action
 * @param {Array} params
 * @return {boolean}
 */
io.nfg.wmg.battle.BattleLogic.prototype.play = function(action, params) {
  var /** @type {string} */ err;
  var /** @type {boolean} */ res;
  io.nfg.wmg.battle.BattleLogic._plog(this._activeUnit.type, "play - " + io.nfg.wmg.battle.BattleLogic.ACTION_NAMES[action], params);
  if (io.nfg.wmg.battle.BattleLogic.ACTION_NAMES[action])
    res = this[io.nfg.wmg.battle.BattleLogic.ACTION_NAMES[action]].apply(this, params);
  else
    err = "Action \"" + action + "\" does not exists";
  if (err)
    io.nfg.wmg.battle.BattleLogic._log("[Error] " + err);
  else
    this._logs.push([action, params]);
  return res;
};


/**
 * @export
 * @param {org.incubatio.Entity} entity
 * @return {boolean}
 */
io.nfg.wmg.battle.BattleLogic.prototype.removeIfDead = function(entity) {
  if (io.nfg.wmg.battle.helpers.UnitHelper.isDead(entity.getComponent(io.nfg.wmg.battle.components.UnitData))) {
    this._unitRemove(entity);
    return true;
  }
  return false;
};


/**
 * @export
 * @param {number} entityId
 * @param {string=} type
 */
io.nfg.wmg.battle.BattleLogic.prototype.unitSkip = function(entityId, type) {
  type = typeof type !== 'undefined' ? type : 'skip';
  var /** @type {org.incubatio.Entity} */ entity = this._entities[entityId];
  this.isNextTurn = true;
  this.addBattlelogEntry(io.nfg.wmg.battle.BattleLogic.SKIP, entity, {type:type});
};


/**
 * @export
 * @param {number} entityId
 * @param {number} gid
 */
io.nfg.wmg.battle.BattleLogic.prototype.unitMove = function(entityId, gid) {
  var /** @type {org.incubatio.Entity} */ entity = this._entities[entityId];
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ unit = entity.getComponent(io.nfg.wmg.battle.components.UnitData);
  if (unit.get('hasMoved'))
    throw new Error('Unit already moved this turn');
  var /** @type {io.nfg.core.Pos} */ pos = this._tileMap.gid2TilePos(gid);
  if (io.nfg.wmg.battle.helpers.StatusHelper.hasStatus(unit, 'tackled'))
    throw 'Unit is tackled, can\'t move';
  var /** @type {Array} */ path = io.nfg.wmg.battle.helpers.BattleHelper.unitMoveTo(entity, pos, this._tileMap, this._tilesInRange);
  var /** @type {number} */ i;
  for (i = path.length - 1; i > -1; i--) {
    if (io.nfg.wmg.battle.helpers.BattleHelper.isTileInRange(path[i], this._tilesInRange))
      break;
    path.pop();
    pos = path[i];
  }
  if (path.length < 1)
    throw "Unit " + entity.toString() + ":" + unit.type + " can't move to" + pos;
  var /** @type {org.incubatio.Entity} */ opportunityEntity;
  var /** @type {number} */ targetGid;
  var /** @type {io.nfg.core.Pos} */ fromPos;
  var /** @type {number} */ attackFromGid;
  var foreachiter12_target = this.attackableEnemies;
  for (var foreachiter12 in foreachiter12_target) 
  {
  opportunityEntity = foreachiter12_target[foreachiter12];
  {
    if (io.nfg.wmg.battle.helpers.BattleHelper.unitIsNextTo(unit, opportunityEntity, this._unitMap, this._tileMap)) {
      if (io.nfg.wmg.battle.helpers.UnitHelper.isAlive(unit)) {
        this._unitReact(opportunityEntity, entity, opportunityEntity.getComponent(io.nfg.wmg.battle.components.UnitData).tilePos, null);
      }
      else
        break;
    }
  }}
  
  this.isNextTurn = false;
  if (this.removeIfDead(entity)) {
    this.isNextTurn = true;
    return;
  }
  var /** @type {io.nfg.wmg.models.SpecialTile} */ specialTile;
  if (io.nfg.wmg.battle.helpers.UnitHelper.isTraversingObstacle(unit) == false) {
    var /** @type {io.nfg.core.Pos} */ pos2;
    for (i in path) {
      pos2 = path[i];
      specialTile = this._tileMap.getSpecialTile(pos2.x, pos2.y, io.nfg.wmg.battle.helpers.UnitHelper.getDim(unit));
      if (specialTile && specialTile.type == io.nfg.wmg.models.SpecialTile.HOLE) {
        path = path.splice(0, i);
        break;
      }
    }
  } else if (io.nfg.wmg.battle.helpers.UnitHelper.isFlying(unit) == false) {
    specialTile = this._tileMap.getSpecialTile(pos.x, pos.y, io.nfg.wmg.battle.helpers.UnitHelper.getDim(unit));
  }
  var /** @type {Object} */ data = {path:path, originPosition:unit.tilePos};
  this.addBattlelogEntry(io.nfg.wmg.battle.BattleLogic.MOVE, entity, data);
  var /** @type {io.nfg.core.Pos} */ coords = specialTile && specialTile.type == io.nfg.wmg.models.SpecialTile.HOLE ? new io.nfg.core.Pos(specialTile.x, specialTile.y) : data.path[data.path.length - 1];
  var /** @type {number} */ l = path.length - 1;
  var /** @type {io.nfg.core.Pos} */ dir = unit.get('direction');
  var /** @type {io.nfg.core.Pos} */ originDir;
  originDir = (l > 1) ? path[l - 1] : unit.tilePos;
  dir.x = (coords.x - originDir.x == 0) ? 0 : (coords.x - originDir.x > 0) ? 1 : -1;
  dir.y = (coords.y - originDir.y == 0) ? 0 : (coords.y - originDir.y > 0) ? 1 : -1;
  io.nfg.wmg.battle.helpers.BattleHelper.moveUnitOnMap(entity, coords.x, coords.y, this._unitMap, this._tileMap.cols, io.nfg.wmg.battle.helpers.UnitHelper.getDim(unit));
  if (specialTile && specialTile.type == io.nfg.wmg.models.SpecialTile.HOLE) {
    io.nfg.wmg.battle.Mechanics.hole(entity, this, new io.nfg.core.Pos(specialTile.x, specialTile.y));
    unit.set('hasJumped', true);
  }
  io.nfg.wmg.battle.BattleLogic._log('unitMove', gid, coords.x, coords.y);
  if (io.nfg.wmg.battle.helpers.UnitHelper.isDead(this._activeUnit))
    this.isNextTurn = true;
  unit.set('hasMoved', true);
  this._updateUnitSurrounding();
  this.updateMeleePenaltyStatus();
};


/**
 * @export
 * @param {number} entityId
 * @param {number} targetGid
 * @param {number=} randFactor1
 * @param {number=} randFactor2
 */
io.nfg.wmg.battle.BattleLogic.prototype.unitAttack = function(entityId, targetGid, randFactor1, randFactor2) {
  randFactor1 = typeof randFactor1 !== 'undefined' ? randFactor1 : -1;
  randFactor2 = typeof randFactor2 !== 'undefined' ? randFactor2 : -1;
  var /** @type {org.incubatio.Entity} */ originEntity = this._entities[entityId];
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ originUnit = originEntity.getComponent(io.nfg.wmg.battle.components.UnitData);
  var /** @type {org.incubatio.Entity} */ targetEntity = this.unitMap[targetGid];
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ targetUnit = targetEntity.getComponent(io.nfg.wmg.battle.components.UnitData);
  if (io.nfg.wmg.battle.helpers.UnitHelper.isRanged(originUnit) == false && io.nfg.wmg.battle.helpers.BattleHelper.isUnitInContact(originUnit, targetUnit, this._tileMap) == false)
    throw new Error('Unit needs to be in contact to be attacked');
  var /** @type {Array} */ actions = [];
  var /** @type {number} */ order;
  actions.push({order:1, method:'_unitAttack', params:[originEntity, targetEntity, originUnit.tilePos, randFactor1]});
  if (io.nfg.wmg.battle.helpers.StatusHelper.hasStatus(originUnit, 'double_attack'))
    actions.push({order:3, method:'_unitAttack', params:[originEntity, targetEntity, originUnit.tilePos, randFactor1]});
  order = io.nfg.wmg.battle.helpers.StatusHelper.hasStatus(targetUnit, 'preemptive') ? 0 : 2;
  actions.push({order:order, method:'_unitReact', params:[targetEntity, originEntity, targetUnit.tilePos, randFactor2]});
  org.apache.royale.utils.Language.sortOn(actions, ['order'], 16);
  var /** @type {Object} */ action;
  var foreachiter13_target = actions;
  for (var foreachiter13 in foreachiter13_target) 
  {
  action = foreachiter13_target[foreachiter13];
  
    if (io.nfg.wmg.battle.helpers.UnitHelper.isAlive(action.params[0].getComponent(io.nfg.wmg.battle.components.UnitData)))
      this[action.method].apply(this, action.params);}
  
};


/**
 * @private
 * @param {org.incubatio.Entity} attackerEntity
 * @param {org.incubatio.Entity} targetEntity
 * @param {io.nfg.core.Pos} attackPos
 * @param {number=} randFactor
 */
io.nfg.wmg.battle.BattleLogic.prototype._unitAttack = function(attackerEntity, targetEntity, attackPos, randFactor) {
  randFactor = typeof randFactor !== 'undefined' ? randFactor : -1;
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ attackerUnit = attackerEntity.getComponent(io.nfg.wmg.battle.components.UnitData);
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ targetUnit = targetEntity.getComponent(io.nfg.wmg.battle.components.UnitData);
  var /** @type {number} */ dmg = 0;
  var /** @type {boolean} */ hasEnemyNeighbour = io.nfg.wmg.battle.helpers.BattleHelper.hasEnemyNeighbour(attackerUnit, this._unitMap, this._tileMap);
  var /** @type {boolean} */ isRangedAttack = (io.nfg.wmg.battle.helpers.UnitHelper.isRanged(attackerUnit) && !hasEnemyNeighbour);
  attackerUnit.set('direction', io.nfg.wmg.battle.helpers.BattleHelper.getDirectionVector(attackPos, targetUnit.tilePos));
  io.nfg.wmg.battle.BattleLogic._log('updateDirection', attackerUnit.type, attackerUnit.get('direction'));
  dmg = io.nfg.wmg.battle.CombatsLogic.computeDamage(attackerUnit, targetUnit, randFactor);
  io.nfg.wmg.battle.helpers.UnitHelper.changeDamageTaken(targetUnit, dmg);
  targetUnit.set('direction', io.nfg.wmg.battle.helpers.BattleHelper.getDirectionVector(targetUnit.tilePos, attackPos));
  io.nfg.wmg.battle.BattleLogic._log('updateDirection', targetUnit.type, targetUnit.get('direction'));
  this.removeIfDead(targetEntity);
  this.isNextTurn = true;
  this.addBattlelogEntry(io.nfg.wmg.battle.BattleLogic.ATTACK, attackerEntity, {targetEntity:targetEntity, damage:dmg, isRangedAttack:isRangedAttack});
};


/**
 * @private
 * @param {org.incubatio.Entity} reactingEntity
 * @param {org.incubatio.Entity} targetEntity
 * @param {io.nfg.core.Pos} attackPos
 * @param {number} randFactor
 */
io.nfg.wmg.battle.BattleLogic.prototype._unitReact = function(reactingEntity, targetEntity, attackPos, randFactor) {
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ reactingUnit = reactingEntity.getComponent(io.nfg.wmg.battle.components.UnitData);
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ targetUnit = targetEntity.getComponent(io.nfg.wmg.battle.components.UnitData);
  if (io.nfg.wmg.battle.helpers.StatusHelper.hasStatus(reactingUnit, 'no_riposte') == false && io.nfg.wmg.battle.helpers.StatusHelper.hasStatus(reactingUnit, 'stunned') == false && io.nfg.wmg.battle.helpers.StatusHelper.hasStatus(targetUnit, 'prevent_riposte') == false) {
    if (io.nfg.wmg.battle.helpers.UnitHelper.canReact(reactingUnit) && reactingEntity != this._activeEntity && io.nfg.wmg.battle.helpers.BattleHelper.unitIsNextTo(reactingUnit, targetEntity, this._unitMap, this._tileMap)) {
      io.nfg.wmg.battle.BattleLogic._log("    " + reactingUnit.type + " is riposting");
      this._unitAttack(reactingEntity, targetEntity, attackPos, randFactor);
      io.nfg.wmg.battle.helpers.UnitHelper.reacted(reactingUnit);
    } else {
      io.nfg.wmg.battle.BattleLogic._log("    " + reactingUnit.type + " can't riposte");
    }
  }
};


/**
 * @private
 * @param {org.incubatio.Entity} entity
 */
io.nfg.wmg.battle.BattleLogic.prototype._unitRemove = function(entity) {
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ unitData = entity.getComponent(io.nfg.wmg.battle.components.UnitData);
  var /** @type {number} */ index;
  var /** @type {Array} */ group;
  var foreachiter14_target = this._allGroups;
  for (var foreachiter14 in foreachiter14_target) 
  {
  group = foreachiter14_target[foreachiter14];
  {
    index = group.indexOf(entity);
    if (index != -1)
      group.splice(index, 1);
  }}
  
  if (entity != this._activeEntity)
    this._tileMap.setTileToFree(unitData.tilePos.x, unitData.tilePos.y, io.nfg.wmg.battle.helpers.UnitHelper.getDim(unitData));
  io.nfg.wmg.battle.helpers.BattleHelper.removeUnitFromMap(unitData, this._unitMap, this._tileMap.cols, io.nfg.wmg.battle.helpers.UnitHelper.getDim(entity.getComponent(io.nfg.wmg.battle.components.UnitData)));
  this._deadGroups[unitData.get('pIndex')].push(entity);
};


/**
 * @export
 * @param {number} entityId
 * @param {string} specialName
 * @param {number} targetGid
 * @param {number=} attackFromGid
 * @param {number=} randFactor1
 * @param {number=} randFactor2
 * @return {boolean}
 */
io.nfg.wmg.battle.BattleLogic.prototype.unitSpecial = function(entityId, specialName, targetGid, attackFromGid, randFactor1, randFactor2) {
  attackFromGid = typeof attackFromGid !== 'undefined' ? attackFromGid : -1;
  randFactor1 = typeof randFactor1 !== 'undefined' ? randFactor1 : -1;
  randFactor2 = typeof randFactor2 !== 'undefined' ? randFactor2 : -1;
  var /** @type {org.incubatio.Entity} */ originEntity = this._entities[entityId];
  try {
    var /** @type {Object} */ config = this._configs.logics.specials[specialName];
    if (config == null)
      throw "No special attack named'" + specialName + "'";
    var /** @type {io.nfg.core.Pos} */ targetPos = this._tileMap.gid2TilePos(targetGid);
    var /** @type {io.nfg.wmg.battle.components.UnitData} */ originUnit = originEntity.getComponent(io.nfg.wmg.battle.components.UnitData);
    var /** @type {Object} */ unitConfig = this._configs.logics.units[originUnit.type];
    var /** @type {number} */ specialIndex = Number(unitConfig.specials.indexOf(specialName));
    if (specialIndex == -1)
      throw "Unit has no special named '" + specialName + "'";
    if (originUnit.deckUnit.hasUpgrade(specialIndex) == false)
      throw 'Unit doesn\'t possesses this special';
    var /** @type {Array} */ actions = [];
    var /** @type {number} */ order;
    var /** @type {Array} */ targets;
    var /** @type {io.nfg.core.Pos} */ targetPos2 = config.mode != 'cast_emptytile' ? targetPos : this._tileMap.gid2TilePos(attackFromGid);
    targets = io.nfg.wmg.battle.helpers.BattleHelper.getTargets(config.targeting, this, targetPos2, attackFromGid, config);
    if (targets.length < 1 && config.mode != 'engender')
      throw "SPECIAL_ERROR_INVALID_TARGET";
    var /** @type {io.nfg.core.Pos} */ attackPos = originUnit.tilePos;
    if (attackFromGid > -1 && config.mode != 'cast_emptytile') {
      if (config.mode != 'melee' && config.mode != 'movecast')
        throw "SPECIAL_ERROR_UNAUTHORIZED_MOVEMENT";
      var /** @type {boolean} */ isInPosition = this._tileMap.tilePos2Gid(originUnit.tilePos.x, originUnit.tilePos.y) == attackFromGid;
      if (this._unitMap[attackFromGid] && this._unitMap[attackFromGid] != originEntity)
        throw 'Can\'t move there, another unit is already on the spot';
      if (!isInPosition)
        this.unitMove(originEntity.id, attackFromGid);
      attackPos = this._tileMap.gid2TilePos(attackFromGid);
    }
    var /** @type {io.nfg.wmg.battle.components.UnitData} */ targetUnit;
    if (config.mode == 'melee') {
      targetUnit = targets[0].getComponent(io.nfg.wmg.battle.components.UnitData);
      order = io.nfg.wmg.battle.helpers.StatusHelper.hasStatus(targetUnit, 'preemptive') ? 0 : 2;
      actions.push({order:order, method:'_unitReact', params:[targets[0], originEntity, targetUnit.tilePos, randFactor2]});
    }
    originUnit.set('direction', io.nfg.wmg.battle.helpers.BattleHelper.getDirectionVector(attackPos, targetPos));
    io.nfg.wmg.battle.BattleLogic._log('updateDirection', originUnit.type, originUnit.get('direction'));
    actions.push({order:1, method:'_unitSpecial', params:[originEntity, specialName, targetPos, targets, config, randFactor1]});
    org.apache.royale.utils.Language.sortOn(actions, ['order'], 16);
    var /** @type {Object} */ action;
    var /** @type {org.incubatio.Entity} */ entity;
    var foreachiter15_target = actions;
    for (var foreachiter15 in foreachiter15_target) 
    {
    action = foreachiter15_target[foreachiter15];
    {
      if (io.nfg.wmg.battle.helpers.UnitHelper.isAlive(action.params[0].getComponent(io.nfg.wmg.battle.components.UnitData)))
        this[action.method].apply(this, action.params);
    }}
    
    this.isNextTurn = true;
    return true;
  } catch (e) {
    if (org.apache.royale.utils.Language.is(e, Error))
      throw e;
    else
      this._reportException(e, "special_attack");
    return false;
  }
};


/**
 * @private
 * @param {org.incubatio.Entity} originEntity
 * @param {string} specialName
 * @param {io.nfg.core.Pos} targetPos
 * @param {Array} targets
 * @param {Object} config
 * @param {number=} randFactor
 */
io.nfg.wmg.battle.BattleLogic.prototype._unitSpecial = function(originEntity, specialName, targetPos, targets, config, randFactor) {
  randFactor = typeof randFactor !== 'undefined' ? randFactor : -1;
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ unit = originEntity.getComponent(io.nfg.wmg.battle.components.UnitData);
  if (io.nfg.wmg.battle.helpers.StatusHelper.hasStatus(unit, 'silenced'))
    throw "SPECIAL_ERROR_SILENCED_UNIT_CANT_SPECIAL";
  if (unit.get('specialCooldowns')[specialName] > 0)
    throw "SPECIAL_ERROR_COOLDOWN";
  var /** @type {string} */ methodName = specialName.replace(/[0-9]/g, '');
  methodName = io.nfg.wmg.battle.SpecialsLogic[methodName] == undefined ? "__generic" : methodName;
  var /** @type {Object} */ options = io.nfg.wmg.battle.SpecialsLogic[methodName](this, originEntity, targetPos, targets, specialName, config, randFactor);
  if (config.mode == 'tile')
    options.targetPos = targetPos;
  options.specialName = specialName;
  options.targetDim = config.dim;
  this.updateMeleePenaltyStatus();
  this.isNextTurn = true;
  unit.get('specialCooldowns')[specialName] = config.cooldown || 2;
  this.addBattlelogEntry(io.nfg.wmg.battle.BattleLogic.SPECIAL, originEntity, options);
};


/**
 * @export
 * @param {string} spellName
 * @param {number} targetGid
 * @param {number=} originGid
 * @param {boolean=} applyCooldown
 * @return {boolean}
 */
io.nfg.wmg.battle.BattleLogic.prototype.spell = function(spellName, targetGid, originGid, applyCooldown) {
  originGid = typeof originGid !== 'undefined' ? originGid : -1;
  applyCooldown = typeof applyCooldown !== 'undefined' ? applyCooldown : true;
  try {
    var /** @type {Object} */ config = this._configs.logics.spells[spellName];
    var /** @type {string} */ methodName = io.nfg.wmg.battle.SpellsLogic[spellName] == undefined ? "__generic" : spellName;
    var /** @type {io.nfg.core.Pos} */ targetPos = this._tileMap.gid2TilePos(targetGid);
    var /** @type {Array} */ targets;
    org.apache.royale.utils.Language.trace(config.targeting, originGid, spellName);
    if (originGid > -1)
      targets = io.nfg.wmg.battle.helpers.BattleHelper.getTargets(config.targeting, this, this._tileMap.gid2TilePos(originGid), null, config);
    else
      targets = io.nfg.wmg.battle.helpers.BattleHelper.getTargets(config.targeting, this, targetPos, null, config);
    if (targets.length < 1)
      throw "SPELL_ERROR_INVALID_TARGET";
    var /** @type {Object} */ options = io.nfg.wmg.battle.SpellsLogic[methodName](this, targetPos, targets, config);
    options.targetPos = targetPos;
    options.spellName = spellName;
    this._updateUnitSurrounding();
    this.addBattlelogEntry(io.nfg.wmg.battle.BattleLogic.SPELL, options.targetEntity, options);
    this.updateMeleePenaltyStatus();
    return true;
  } catch (e) {
    if (org.apache.royale.utils.Language.is(e, Error))
      throw e;
    else
      this._reportException(e, "spell");
    return false;
  }
};


/**
 * @export
 */
io.nfg.wmg.battle.BattleLogic.prototype.updateMeleePenaltyStatus = function() {
  var /** @type {org.incubatio.Entity} */ entity;
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ unit;
  var foreachiter16_target = this._aliveEntities;
  for (var foreachiter16 in foreachiter16_target) 
  {
  entity = foreachiter16_target[foreachiter16];
  {
    unit = entity.getComponent(io.nfg.wmg.battle.components.UnitData);
    if (io.nfg.wmg.battle.helpers.UnitHelper.isRanged(unit)) {
      io.nfg.wmg.battle.helpers.BattleHelper.hasEnemyNeighbour(unit, this._unitMap, this._tileMap) ? io.nfg.wmg.battle.helpers.StatusHelper.addStatus(entity, "melee_penalty") : io.nfg.wmg.battle.helpers.StatusHelper.removeStatus(entity, "melee_penalty");
    }
  }}
  
};


/**
 * @export
 * @param {org.incubatio.Entity} a
 * @param {org.incubatio.Entity} b
 * @return {number}
 */
io.nfg.wmg.battle.BattleLogic.prototype.sortUnits = function(a, b) {
  var /** @type {number} */ iA = io.nfg.wmg.battle.helpers.UnitHelper.getInitiative(org.apache.royale.utils.Language.as(a.getComponent(io.nfg.wmg.battle.components.UnitData), io.nfg.wmg.battle.components.UnitData), this.roundNumber);
  var /** @type {number} */ iB = io.nfg.wmg.battle.helpers.UnitHelper.getInitiative(org.apache.royale.utils.Language.as(b.getComponent(io.nfg.wmg.battle.components.UnitData), io.nfg.wmg.battle.components.UnitData), this.roundNumber);
  if (iA == iB) {
    var /** @type {number} */ hA = this.entities.indexOf(a);
    var /** @type {number} */ hB = this.entities.indexOf(b);
    var /** @type {number} */ tmp = hA < hB ? -1 : 1;
    return iA < 0 ? -tmp : tmp;
  }
  else
    return iA > iB ? -1 : 1;
};


io.nfg.wmg.battle.BattleLogic.prototype.get__isNextRound = function() {
  return this._allGroups["units_in_round"].length < 1;
};


io.nfg.wmg.battle.BattleLogic.prototype.get__isPlayerTurn = function() {
  return this._playerTypes[this._activeUnit.get('pIndex')] == io.nfg.wmg.models.PlayerTypes.LOCAL;
};


io.nfg.wmg.battle.BattleLogic.prototype.get__logs = function() {
  return this._logs;
};


io.nfg.wmg.battle.BattleLogic.prototype.get__activeEntity = function() {
  return this._activeEntity;
};


io.nfg.wmg.battle.BattleLogic.prototype.get__activeUnit = function() {
  return this._activeUnit;
};


io.nfg.wmg.battle.BattleLogic.prototype.get__activeUnitHasEnemyNeighbour = function() {
  return this._activeUnitHasEnemyNeighbour;
};


io.nfg.wmg.battle.BattleLogic.prototype.get__unitMap = function() {
  return this._unitMap;
};


io.nfg.wmg.battle.BattleLogic.prototype.get__tileMap = function() {
  return this._tileMap;
};


io.nfg.wmg.battle.BattleLogic.prototype.get__tilesInRange = function() {
  return this._tilesInRange;
};


io.nfg.wmg.battle.BattleLogic.prototype.get__attackableEnemies = function() {
  return this._attackableEnemies;
};


io.nfg.wmg.battle.BattleLogic.prototype.get__gameModes = function() {
  return this._gameModes;
};


io.nfg.wmg.battle.BattleLogic.prototype.get__entities = function() {
  return this._entities;
};


io.nfg.wmg.battle.BattleLogic.prototype.get__unitsInRound = function() {
  return this._allGroups["units_in_round"];
};


io.nfg.wmg.battle.BattleLogic.prototype.get__aliveGroups = function() {
  return this._aliveGroups;
};


io.nfg.wmg.battle.BattleLogic.prototype.get__aliveEntities = function() {
  return this._aliveEntities;
};


io.nfg.wmg.battle.BattleLogic.prototype.get__deadGroups = function() {
  return this._deadGroups;
};


io.nfg.wmg.battle.BattleLogic.prototype.get__playerTypes = function() {
  return this._playerTypes;
};


io.nfg.wmg.battle.BattleLogic.prototype.get__tilesInRangeMap = function() {
  return this._tilesInRangeMap;
};


Object.defineProperties(io.nfg.wmg.battle.BattleLogic.prototype, /** @lends {io.nfg.wmg.battle.BattleLogic.prototype} */ {
/**
  * @export
  * @type {boolean} */
isNextRound: {
get: io.nfg.wmg.battle.BattleLogic.prototype.get__isNextRound},
/**
  * @export
  * @type {boolean} */
isPlayerTurn: {
get: io.nfg.wmg.battle.BattleLogic.prototype.get__isPlayerTurn},
/**
  * @export
  * @type {Array} */
logs: {
get: io.nfg.wmg.battle.BattleLogic.prototype.get__logs},
/**
  * @export
  * @type {org.incubatio.Entity} */
activeEntity: {
get: io.nfg.wmg.battle.BattleLogic.prototype.get__activeEntity},
/**
  * @export
  * @type {io.nfg.wmg.battle.components.UnitData} */
activeUnit: {
get: io.nfg.wmg.battle.BattleLogic.prototype.get__activeUnit},
/**
  * @export
  * @type {boolean} */
activeUnitHasEnemyNeighbour: {
get: io.nfg.wmg.battle.BattleLogic.prototype.get__activeUnitHasEnemyNeighbour},
/**
  * @export
  * @type {Array} */
unitMap: {
get: io.nfg.wmg.battle.BattleLogic.prototype.get__unitMap},
/**
  * @export
  * @type {org.incubatio.TileMap} */
tileMap: {
get: io.nfg.wmg.battle.BattleLogic.prototype.get__tileMap},
/**
  * @export
  * @type {Vector.<Pos>} */
tilesInRange: {
get: io.nfg.wmg.battle.BattleLogic.prototype.get__tilesInRange},
/**
  * @export
  * @type {Vector.<Entity>} */
attackableEnemies: {
get: io.nfg.wmg.battle.BattleLogic.prototype.get__attackableEnemies},
/**
  * @export
  * @type {Object} */
gameModes: {
get: io.nfg.wmg.battle.BattleLogic.prototype.get__gameModes},
/**
  * @export
  * @type {Vector.<Entity>} */
entities: {
get: io.nfg.wmg.battle.BattleLogic.prototype.get__entities},
/**
  * @export
  * @type {Vector.<Entity>} */
unitsInRound: {
get: io.nfg.wmg.battle.BattleLogic.prototype.get__unitsInRound},
/**
  * @export
  * @type {Object} */
aliveGroups: {
get: io.nfg.wmg.battle.BattleLogic.prototype.get__aliveGroups},
/**
  * @export
  * @type {Vector.<Entity>} */
aliveEntities: {
get: io.nfg.wmg.battle.BattleLogic.prototype.get__aliveEntities},
/**
  * @export
  * @type {Object} */
deadGroups: {
get: io.nfg.wmg.battle.BattleLogic.prototype.get__deadGroups},
/**
  * @export
  * @type {Object} */
playerTypes: {
get: io.nfg.wmg.battle.BattleLogic.prototype.get__playerTypes},
/**
  * @export
  * @type {Vector.<boolean>} */
tilesInRangeMap: {
get: io.nfg.wmg.battle.BattleLogic.prototype.get__tilesInRangeMap}}
);

io.nfg.wmg.battle.BattleLogic._log = io.nfg.core.Tools.createLogger(io.nfg.wmg.battle.BattleLogic, 'battle-logic');
io.nfg.wmg.battle.BattleLogic._plog = io.nfg.core.Tools.createLogger(io.nfg.wmg.battle.BattleLogic, 'battle-play');
io.nfg.wmg.battle.BattleLogic._logStatus = io.nfg.core.Tools.createLogger(io.nfg.wmg.battle.BattleLogic, 'status');




/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
io.nfg.wmg.battle.BattleLogic.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'BattleLogic', qName: 'io.nfg.wmg.battle.BattleLogic', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
io.nfg.wmg.battle.BattleLogic.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        '|ACTION_NAMES': { type: 'Object'},
        'enemyIndex': { type: 'Number'},
        'roundNumber': { type: 'Number'},
        'isNextTurn': { type: 'Boolean'},
        'addBattlelogEntry': { type: 'Function'}
      };
    },
    accessors: function () {
      return {
        'isNextRound': { type: 'Boolean', access: 'readonly', declaredBy: 'io.nfg.wmg.battle.BattleLogic'},
        'isPlayerTurn': { type: 'Boolean', access: 'readonly', declaredBy: 'io.nfg.wmg.battle.BattleLogic'},
        'logs': { type: 'Array', access: 'readonly', declaredBy: 'io.nfg.wmg.battle.BattleLogic'},
        'activeEntity': { type: 'org.incubatio.Entity', access: 'readonly', declaredBy: 'io.nfg.wmg.battle.BattleLogic'},
        'activeUnit': { type: 'io.nfg.wmg.battle.components.UnitData', access: 'readonly', declaredBy: 'io.nfg.wmg.battle.BattleLogic'},
        'activeUnitHasEnemyNeighbour': { type: 'Boolean', access: 'readonly', declaredBy: 'io.nfg.wmg.battle.BattleLogic'},
        'unitMap': { type: 'Array', access: 'readonly', declaredBy: 'io.nfg.wmg.battle.BattleLogic'},
        'tileMap': { type: 'org.incubatio.TileMap', access: 'readonly', declaredBy: 'io.nfg.wmg.battle.BattleLogic'},
        'tilesInRange': { type: 'Vector.<io.nfg.core.Pos>', access: 'readonly', declaredBy: 'io.nfg.wmg.battle.BattleLogic'},
        'attackableEnemies': { type: 'Vector.<org.incubatio.Entity>', access: 'readonly', declaredBy: 'io.nfg.wmg.battle.BattleLogic'},
        'gameModes': { type: 'Object', access: 'readonly', declaredBy: 'io.nfg.wmg.battle.BattleLogic'},
        'entities': { type: 'Vector.<org.incubatio.Entity>', access: 'readonly', declaredBy: 'io.nfg.wmg.battle.BattleLogic'},
        'unitsInRound': { type: 'Vector.<org.incubatio.Entity>', access: 'readonly', declaredBy: 'io.nfg.wmg.battle.BattleLogic'},
        'aliveGroups': { type: 'Object', access: 'readonly', declaredBy: 'io.nfg.wmg.battle.BattleLogic'},
        'aliveEntities': { type: 'Vector.<org.incubatio.Entity>', access: 'readonly', declaredBy: 'io.nfg.wmg.battle.BattleLogic'},
        'deadGroups': { type: 'Object', access: 'readonly', declaredBy: 'io.nfg.wmg.battle.BattleLogic'},
        'playerTypes': { type: 'Object', access: 'readonly', declaredBy: 'io.nfg.wmg.battle.BattleLogic'},
        'tilesInRangeMap': { type: 'Vector.<Boolean>', access: 'readonly', declaredBy: 'io.nfg.wmg.battle.BattleLogic'}
      };
    },
    methods: function () {
      return {
        'BattleLogic': { type: '', declaredBy: 'io.nfg.wmg.battle.BattleLogic', parameters: function () { return [  { index: 1, type: 'Vector.<org.incubatio.Entity>', optional: false },{ index: 2, type: 'Vector.<io.nfg.wmg.models.Actor>', optional: false },{ index: 3, type: 'org.incubatio.TileMap', optional: false },{ index: 4, type: 'Vector.<Object>', optional: false },{ index: 5, type: 'Object', optional: false } ]; }},
        '|fromMission': { type: 'io.nfg.wmg.battle.BattleLogic', declaredBy: 'io.nfg.wmg.battle.BattleLogic', parameters: function () { return [  { index: 1, type: 'io.nfg.wmg.models.Mission', optional: false },{ index: 2, type: 'Object', optional: false } ]; }},
        'clearUnits': { type: 'void', declaredBy: 'io.nfg.wmg.battle.BattleLogic'},
        'nextRound': { type: 'void', declaredBy: 'io.nfg.wmg.battle.BattleLogic', parameters: function () { return [  { index: 1, type: 'Function', optional: true } ]; }},
        'didGameEnded': { type: 'Boolean', declaredBy: 'io.nfg.wmg.battle.BattleLogic', parameters: function () { return [  { index: 1, type: 'Number', optional: false } ]; }},
        'nextTurn': { type: 'void', declaredBy: 'io.nfg.wmg.battle.BattleLogic', parameters: function () { return [  { index: 1, type: 'Function', optional: false } ]; }},
        'play': { type: 'Boolean', declaredBy: 'io.nfg.wmg.battle.BattleLogic', parameters: function () { return [  { index: 1, type: 'Number', optional: false },{ index: 2, type: 'Array', optional: false } ]; }},
        'removeIfDead': { type: 'Boolean', declaredBy: 'io.nfg.wmg.battle.BattleLogic', parameters: function () { return [  { index: 1, type: 'org.incubatio.Entity', optional: false } ]; }},
        'unitSkip': { type: 'void', declaredBy: 'io.nfg.wmg.battle.BattleLogic', parameters: function () { return [  { index: 1, type: 'Number', optional: false },{ index: 2, type: 'String', optional: true } ]; }},
        'unitMove': { type: 'void', declaredBy: 'io.nfg.wmg.battle.BattleLogic', parameters: function () { return [  { index: 1, type: 'Number', optional: false },{ index: 2, type: 'Number', optional: false } ]; }},
        'unitAttack': { type: 'void', declaredBy: 'io.nfg.wmg.battle.BattleLogic', parameters: function () { return [  { index: 1, type: 'Number', optional: false },{ index: 2, type: 'Number', optional: false },{ index: 3, type: 'Number', optional: true },{ index: 4, type: 'Number', optional: true } ]; }},
        'unitSpecial': { type: 'Boolean', declaredBy: 'io.nfg.wmg.battle.BattleLogic', parameters: function () { return [  { index: 1, type: 'Number', optional: false },{ index: 2, type: 'String', optional: false },{ index: 3, type: 'Number', optional: false },{ index: 4, type: 'Number', optional: true },{ index: 5, type: 'Number', optional: true },{ index: 6, type: 'Number', optional: true } ]; }},
        'spell': { type: 'Boolean', declaredBy: 'io.nfg.wmg.battle.BattleLogic', parameters: function () { return [  { index: 1, type: 'String', optional: false },{ index: 2, type: 'Number', optional: false },{ index: 3, type: 'Number', optional: true },{ index: 4, type: 'Boolean', optional: true } ]; }},
        'updateMeleePenaltyStatus': { type: 'void', declaredBy: 'io.nfg.wmg.battle.BattleLogic'},
        'sortUnits': { type: 'Number', declaredBy: 'io.nfg.wmg.battle.BattleLogic', parameters: function () { return [  { index: 1, type: 'org.incubatio.Entity', optional: false },{ index: 2, type: 'org.incubatio.Entity', optional: false } ]; }}
      };
    }
  };
};