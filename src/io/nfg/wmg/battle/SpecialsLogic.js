/**
 * Generated by Apache Royale Compiler from io/nfg/wmg/battle/SpecialsLogic.as
 * io.nfg.wmg.battle.SpecialsLogic
 *
 * @fileoverview
 *
 * @suppress {checkTypes|accessControls}
 */

goog.provide('io.nfg.wmg.battle.SpecialsLogic');
/* Royale Static Dependency List: io.nfg.core.Tools,io.nfg.wmg.battle.SpecialsLogic*/

goog.require('io.nfg.core.Pos');
goog.require('io.nfg.core.Tools');
goog.require('io.nfg.wmg.battle.BattleLogic');
goog.require('io.nfg.wmg.battle.CombatsLogic');
goog.require('io.nfg.wmg.battle.EntityFactory');
goog.require('io.nfg.wmg.battle.Mechanics');
goog.require('io.nfg.wmg.battle.SpellsLogic');
goog.require('io.nfg.wmg.battle.components.UnitData');
goog.require('io.nfg.wmg.battle.helpers.BattleHelper');
goog.require('io.nfg.wmg.battle.helpers.StatusHelper');
goog.require('io.nfg.wmg.battle.helpers.UnitHelper');
goog.require('io.nfg.wmg.models.DeckUnit');
goog.require('org.incubatio.Entity');
goog.require('org.apache.royale.utils.Language');



/**
 * @constructor
 */
io.nfg.wmg.battle.SpecialsLogic = function() {
  throw new Error('cannot be instanciated');
};


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('io.nfg.wmg.battle.SpecialsLogic', io.nfg.wmg.battle.SpecialsLogic);


/**
 * @private
 * @type {Function}
 */
io.nfg.wmg.battle.SpecialsLogic._log;


/**
 * @export
 * @param {io.nfg.wmg.battle.BattleLogic} battle
 * @param {org.incubatio.Entity} originEntity
 * @param {io.nfg.core.Pos} targetPos
 * @param {Array} targets
 * @param {string} specialName
 * @param {Object} config
 * @param {number=} randFactor
 * @return {Object}
 */
io.nfg.wmg.battle.SpecialsLogic.shamanFlare = function(battle, originEntity, targetPos, targets, specialName, config, randFactor) {
  randFactor = typeof randFactor !== 'undefined' ? randFactor : -1;
  var /** @type {Object} */ options = {};
  options.targets = targets;
  options.targetEntity = targets[0];
  io.nfg.wmg.battle.SpellsLogic.energize(battle, targetPos, targets, config);
  return options;
};


/**
 * @export
 * @param {io.nfg.wmg.battle.BattleLogic} battle
 * @param {org.incubatio.Entity} originEntity
 * @param {io.nfg.core.Pos} targetPos
 * @param {Array} targets
 * @param {string} specialName
 * @param {Object} config
 * @param {number=} randFactor
 * @return {Object}
 */
io.nfg.wmg.battle.SpecialsLogic.__generic = function(battle, originEntity, targetPos, targets, specialName, config, randFactor) {
  randFactor = typeof randFactor !== 'undefined' ? randFactor : -1;
  io.nfg.wmg.battle.SpecialsLogic._log('Special:', config);
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ originUnit = originEntity.getComponent(io.nfg.wmg.battle.components.UnitData);
  var /** @type {string} */ status;
  var /** @type {org.incubatio.Entity} */ targetEntity;
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ targetUnit;
  var /** @type {io.nfg.core.Pos} */ directionVector;
  var /** @type {number} */ distance;
  var /** @type {number} */ damage = 0;
  var /** @type {Object} */ options = {};
  options.targets = targets;
  options.originEntity = originEntity;
  if (config.targeting == 'twotiles' || config.targeting == null)
    options.targetEntity = targets[0];
  if (config['applySkills']) {
    io.nfg.wmg.battle.SpecialsLogic._log('applying skills');
    var foreachiter0_target = config['applySkills'];
    for (var foreachiter0 in foreachiter0_target) 
    {
    status = foreachiter0_target[foreachiter0];
    {
      io.nfg.wmg.battle.helpers.StatusHelper.addStatus(originEntity, status);
    }}
    
  }
  var foreachiter1_target = targets;
  for (var foreachiter1 in foreachiter1_target) 
  {
  targetEntity = foreachiter1_target[foreachiter1];
  {
    targetUnit = targetEntity.getComponent(io.nfg.wmg.battle.components.UnitData);
    damage = 0;
    if (config.atk || config.mag) {
      damage = io.nfg.wmg.battle.CombatsLogic.computeSpecialDamage(originUnit, targetUnit, specialName);
      options.damage = damage;
    }
    if (damage != 0) {
      io.nfg.wmg.battle.SpecialsLogic._log('applying damages');
      io.nfg.wmg.battle.helpers.UnitHelper.changeDamageTaken(targetUnit, damage);
    }
    if (config.push || config.pull) {
      var /** @type {io.nfg.wmg.battle.components.UnitData} */ destUnit = config.push ? targetUnit : originUnit;
      var /** @type {io.nfg.core.Pos} */ goal = destUnit.tilePos.clone();
      goal.x += io.nfg.wmg.battle.helpers.UnitHelper.getDim(destUnit) * .5;
      goal.y += io.nfg.wmg.battle.helpers.UnitHelper.getDim(destUnit) * .5;
      var /** @type {io.nfg.wmg.battle.components.UnitData} */ startUnit = config.push ? originUnit : targetUnit;
      var /** @type {io.nfg.core.Pos} */ start = startUnit.tilePos.clone();
      start.x += io.nfg.wmg.battle.helpers.UnitHelper.getDim(startUnit) * .5;
      start.y += io.nfg.wmg.battle.helpers.UnitHelper.getDim(startUnit) * .5;
      battle.tileMap.setTileToOccupied(originUnit.tilePos.x, originUnit.tilePos.y, originUnit.dim);
      options.pushConfig = io.nfg.wmg.battle.Mechanics.push(targetEntity, battle, start, goal, config.push || config.pull);
      battle.tileMap.setTileToFree(originUnit.tilePos.x, originUnit.tilePos.y, originUnit.dim);
      io.nfg.wmg.battle.SpecialsLogic._log('pushing or pulling', options.pushConfig, distance);
    }
    if (battle.removeIfDead(targetEntity) == false) {
      if (config['applyStatuses']) {
        io.nfg.wmg.battle.SpecialsLogic._log('applying statuses');
        var foreachiter2_target = config['applyStatuses'];
        for (var foreachiter2 in foreachiter2_target) 
        {
        status = foreachiter2_target[foreachiter2];
        {
          io.nfg.wmg.battle.helpers.StatusHelper.addStatus(targetEntity, status, originEntity);
        }}
        
      }
    }
  }}
  
  return options;
};


/**
 * @private
 * @param {io.nfg.wmg.battle.BattleLogic} battle
 * @param {org.incubatio.Entity} originEntity
 * @param {io.nfg.core.Pos} targetPos
 * @param {Array} targets
 * @param {string} unitName
 * @return {Object}
 */
io.nfg.wmg.battle.SpecialsLogic._summon = function(battle, originEntity, targetPos, targets, unitName) {
  var /** @type {Object} */ options = {};
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ originUnit = originEntity.getComponent(io.nfg.wmg.battle.components.UnitData);
  var /** @type {io.nfg.wmg.battle.components.UnitData} */ targetUnit;
  if (!io.nfg.wmg.battle.helpers.BattleHelper.isTileInContact(targetPos, originUnit, battle.tileMap))
    throw "SPECIAL_ERROR_BAD_POSITION_FOR_SPAWN";
  var /** @type {org.incubatio.Entity} */ entity = io.nfg.wmg.battle.EntityFactory.create(battle.entities.length, new io.nfg.wmg.models.DeckUnit({type:unitName, pos:[targetPos.x, targetPos.y]}), battle.activeUnit.get('pIndex'));
  targetUnit = entity.getComponent(io.nfg.wmg.battle.components.UnitData);
  var /** @type {number} */ dim = io.nfg.wmg.battle.helpers.UnitHelper.getDim(targetUnit);
  if (battle.tileMap.isOccupied(targetPos.x, targetPos.y, dim))
    throw "SPECIAL_ERROR_INSUFICIENT_SPACE_SPAWN";
  targetUnit.set('tilePos', targetPos);
  battle.aliveEntities.push(entity);
  battle.aliveGroups[battle.activeUnit.get('pIndex')].push(entity);
  battle.entities.push(entity);
  battle.unitsInRound.push(entity);
  battle.unitsInRound.sort(org.apache.royale.utils.Language.closure(battle.sortUnits, battle, 'sortUnits'));
  battle.tileMap.setTileToOccupied(targetUnit.tilePos.x, targetUnit.tilePos.y, dim);
  io.nfg.wmg.battle.helpers.BattleHelper.placeUnitOnMap(entity, battle.unitMap, battle.tileMap.cols, dim);
  originUnit.set('direction', io.nfg.wmg.battle.helpers.BattleHelper.getDirectionVector(originUnit.tilePos, targetUnit.tilePos));
  originUnit.get('direction').setTo(-originUnit.get('direction').x, -originUnit.get('direction').y);
  options.targetPos = targetPos;
  options.targetEntity = entity;
  targets.push(entity);
  options.targets = targets;
  return options;
};


/**
 * @export
 * @param {io.nfg.wmg.battle.BattleLogic} battle
 * @param {org.incubatio.Entity} originEntity
 * @param {io.nfg.core.Pos} targetPos
 * @param {Array} targets
 * @param {string} specialName
 * @param {Object} config
 * @param {number=} randFactor
 * @return {Object}
 */
io.nfg.wmg.battle.SpecialsLogic.iq_layegg = function(battle, originEntity, targetPos, targets, specialName, config, randFactor) {
  randFactor = typeof randFactor !== 'undefined' ? randFactor : -1;
  return io.nfg.wmg.battle.SpecialsLogic._summon(battle, originEntity, targetPos, targets, 'stalker');
};


/**
 * @export
 * @param {io.nfg.wmg.battle.BattleLogic} battle
 * @param {org.incubatio.Entity} originEntity
 * @param {io.nfg.core.Pos} targetPos
 * @param {Array} targets
 * @param {string} specialName
 * @param {Object} config
 * @param {number=} randFactor
 * @return {Object}
 */
io.nfg.wmg.battle.SpecialsLogic.bs_teleport = function(battle, originEntity, targetPos, targets, specialName, config, randFactor) {
  randFactor = typeof randFactor !== 'undefined' ? randFactor : -1;
  var /** @type {Object} */ options = io.nfg.wmg.battle.SpecialsLogic.__generic(battle, originEntity, targetPos, targets, specialName, config);
  options.targets = targets;
  options.targetPos = targetPos;
  options.targetEntity = targets[0];
  io.nfg.wmg.battle.Mechanics.teleport(battle, options.targetEntity, targetPos, config.range);
  if (originEntity.getComponent(io.nfg.wmg.battle.components.UnitData).get('hasFallen'))
    options.damage = 0;
  return options;
};


/**
 * @export
 * @param {io.nfg.wmg.battle.BattleLogic} battle
 * @param {org.incubatio.Entity} originEntity
 * @param {io.nfg.core.Pos} targetPos
 * @param {Array} targets
 * @param {string} specialName
 * @param {Object} config
 * @param {number=} randFactor
 * @return {Object}
 */
io.nfg.wmg.battle.SpecialsLogic.gc_rocketjump = function(battle, originEntity, targetPos, targets, specialName, config, randFactor) {
  randFactor = typeof randFactor !== 'undefined' ? randFactor : -1;
  var /** @type {Object} */ options = io.nfg.wmg.battle.SpecialsLogic.__generic(battle, originEntity, targetPos, targets, specialName, config);
  options.targetPos = targetPos;
  io.nfg.wmg.battle.Mechanics.teleport(battle, originEntity, targetPos, config.range);
  if (originEntity.getComponent(io.nfg.wmg.battle.components.UnitData).get('hasFallen'))
    options.damage = 0;
  return options;
};


/**
 * @export
 * @param {io.nfg.wmg.battle.BattleLogic} battle
 * @param {org.incubatio.Entity} originEntity
 * @param {io.nfg.core.Pos} targetPos
 * @param {Array} targets
 * @param {string} specialName
 * @param {Object} config
 * @param {number=} randFactor
 * @return {Object}
 */
io.nfg.wmg.battle.SpecialsLogic.wait = function(battle, originEntity, targetPos, targets, specialName, config, randFactor) {
  randFactor = typeof randFactor !== 'undefined' ? randFactor : -1;
  if (battle.activeUnit.get('hasWaited'))
    throw 'unit already waited';
  battle.activeUnit.set('hasWaited', true);
  battle.unitsInRound.push(originEntity);
  battle.unitsInRound.sort(org.apache.royale.utils.Language.closure(battle.sortUnits, battle, 'sortUnits'));
  return {};
};

io.nfg.wmg.battle.SpecialsLogic._log = io.nfg.core.Tools.createLogger(io.nfg.wmg.battle.SpecialsLogic, "specials");




/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
io.nfg.wmg.battle.SpecialsLogic.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'SpecialsLogic', qName: 'io.nfg.wmg.battle.SpecialsLogic', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
io.nfg.wmg.battle.SpecialsLogic.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {return {};},
    accessors: function () {return {};},
    methods: function () {
      return {
        'SpecialsLogic': { type: '', declaredBy: 'io.nfg.wmg.battle.SpecialsLogic'},
        '|shamanFlare': { type: 'Object', declaredBy: 'io.nfg.wmg.battle.SpecialsLogic', parameters: function () { return [  { index: 1, type: 'io.nfg.wmg.battle.BattleLogic', optional: false },{ index: 2, type: 'org.incubatio.Entity', optional: false },{ index: 3, type: 'io.nfg.core.Pos', optional: false },{ index: 4, type: 'Vector.<org.incubatio.Entity>', optional: false },{ index: 5, type: 'String', optional: false },{ index: 6, type: 'Object', optional: false },{ index: 7, type: 'Number', optional: true } ]; }},
        '|__generic': { type: 'Object', declaredBy: 'io.nfg.wmg.battle.SpecialsLogic', parameters: function () { return [  { index: 1, type: 'io.nfg.wmg.battle.BattleLogic', optional: false },{ index: 2, type: 'org.incubatio.Entity', optional: false },{ index: 3, type: 'io.nfg.core.Pos', optional: false },{ index: 4, type: 'Vector.<org.incubatio.Entity>', optional: false },{ index: 5, type: 'String', optional: false },{ index: 6, type: 'Object', optional: false },{ index: 7, type: 'Number', optional: true } ]; }},
        '|iq_layegg': { type: 'Object', declaredBy: 'io.nfg.wmg.battle.SpecialsLogic', parameters: function () { return [  { index: 1, type: 'io.nfg.wmg.battle.BattleLogic', optional: false },{ index: 2, type: 'org.incubatio.Entity', optional: false },{ index: 3, type: 'io.nfg.core.Pos', optional: false },{ index: 4, type: 'Vector.<org.incubatio.Entity>', optional: false },{ index: 5, type: 'String', optional: false },{ index: 6, type: 'Object', optional: false },{ index: 7, type: 'Number', optional: true } ]; }},
        '|bs_teleport': { type: 'Object', declaredBy: 'io.nfg.wmg.battle.SpecialsLogic', parameters: function () { return [  { index: 1, type: 'io.nfg.wmg.battle.BattleLogic', optional: false },{ index: 2, type: 'org.incubatio.Entity', optional: false },{ index: 3, type: 'io.nfg.core.Pos', optional: false },{ index: 4, type: 'Vector.<org.incubatio.Entity>', optional: false },{ index: 5, type: 'String', optional: false },{ index: 6, type: 'Object', optional: false },{ index: 7, type: 'Number', optional: true } ]; }},
        '|gc_rocketjump': { type: 'Object', declaredBy: 'io.nfg.wmg.battle.SpecialsLogic', parameters: function () { return [  { index: 1, type: 'io.nfg.wmg.battle.BattleLogic', optional: false },{ index: 2, type: 'org.incubatio.Entity', optional: false },{ index: 3, type: 'io.nfg.core.Pos', optional: false },{ index: 4, type: 'Vector.<org.incubatio.Entity>', optional: false },{ index: 5, type: 'String', optional: false },{ index: 6, type: 'Object', optional: false },{ index: 7, type: 'Number', optional: true } ]; }},
        '|wait': { type: 'Object', declaredBy: 'io.nfg.wmg.battle.SpecialsLogic', parameters: function () { return [  { index: 1, type: 'io.nfg.wmg.battle.BattleLogic', optional: false },{ index: 2, type: 'org.incubatio.Entity', optional: false },{ index: 3, type: 'io.nfg.core.Pos', optional: false },{ index: 4, type: 'Vector.<org.incubatio.Entity>', optional: false },{ index: 5, type: 'String', optional: false },{ index: 6, type: 'Object', optional: false },{ index: 7, type: 'Number', optional: true } ]; }}
      };
    }
  };
};